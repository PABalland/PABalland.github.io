<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <script src="https://www.paballand.com/js/d3plus-plot.v0.9.full.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, Helvetica, sans-serif;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #chart {
            flex: 1 1 auto;
        }

        .footer-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            width: 100%;
            padding: 0 10px 10px 10px;
            box-sizing: border-box;
            min-height: 40px;
        }

        .legend {
            display: flex;
            justify-content: center;
            padding: 12px 0;
            z-index: 2;
            white-space: nowrap;
        }

        #chart-footnote {
            position: absolute;
            right: 10px;
            bottom: 12px;
            text-align: right;
            font-size: 11px;
            color: #888;
            font-style: italic;
            z-index: 1;
            pointer-events: none;
        }

        @media (max-width: 850px) {
            .footer-wrapper {
                flex-direction: column;
                align-items: center;
            }

            #chart-footnote {
                position: static;
                margin-top: 5px;
                text-align: center;
                max-width: 100%;
            }
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 24px;
            font-size: 14px;
        }

        .box {
            width: 14px;
            height: 14px;
            margin-right: 10px;
            border: none;
        }

        .pos {
            background: #2d7c2d;
        }

        .neg {
            background: #8B1A0F;
        }

        .tooltip-table {
            width: 100%;
        }

        .tooltip-table .data {
            text-align: right;
        }

        .tooltip-footer {
            opacity: .5;
        }

        tspan {
            font-family: "Helvetica", "Arial", sans-serif;
            font-size: 100px;
            font-style: oblique;
        }

        .custom-label {
            font-family: Arial, Helvetica, sans-serif;
            font-size: 13px;
            fill: #000;
            opacity: 1;
            font-weight: normal;
            transition: opacity 0.4s ease, font-size 0.4s ease, font-weight 0.4s ease;
            pointer-events: none;
            transform-origin: center;
        }

        .custom-label.collision {
            opacity: 0.3;
        }

        .custom-label.hover {
            opacity: 1 !important;
            font-size: 16px !important;
            font-weight: bold !important;
        }

        .custom-label,
        text.custom-label {
            font-family: Arial, Helvetica, sans-serif !important;
            font-size: 13px;
            fill: #000 !important;
            stroke: none !important;
            font-weight: normal !important;
        }

        .connector-line {
            stroke: #000;
            stroke-width: 1px;
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="chart"></div>
        <div class="footer-wrapper">
            <div class="legend">
                <div class="legend-item"><span class="box pos"></span><span>Investment RCA &gt; 1</span></div>
                <div class="legend-item"><span class="box neg"></span><span>Investment RCA &lt; 1</span></div>
            </div>
            <div id="chart-footnote"></div>
        </div>
    </div>
    <script>
        function median(v) {
            if (!v.length) throw new Error("empty");
            v = [...v].sort((a, b) => a - b);
            const h = Math.floor(v.length / 2);
            return v.length % 2 ? v[h] : (v[h - 1] + v[h]) / 2;
        }

        function truncateText(text, maxLength = 35) {
            if (text.length <= maxLength) {
                return text;
            }
            return text.substring(0, maxLength) + "...";
        }

        function rectanglesOverlap(rect1, rect2) {
            return !(rect1.x + rect1.width < rect2.x ||
                rect2.x + rect2.width < rect1.x ||
                rect1.y + rect1.height < rect2.y ||
                rect2.y + rect2.height < rect1.y);
        }

        function getPositionOptions(centerX, centerY, radius, padding = 8) {
            const card = [
                { name: 'right', x: centerX + radius + padding, y: centerY + 5, anchor: 'start' },
                { name: 'left', x: centerX - radius - padding, y: centerY + 5, anchor: 'end' },
                { name: 'below', x: centerX, y: centerY + radius + padding + 10, anchor: 'middle' },
                { name: 'above', x: centerX, y: centerY - radius - padding, anchor: 'middle' }
            ];

            const diagPad = padding;
            const diagOffset = (radius + diagPad) * 0.707;
            const extraX = 4;

            const diag = [
                { name: 'top-right', x: centerX + diagOffset + extraX, y: centerY - diagOffset, anchor: 'start' },
                { name: 'bottom-right', x: centerX + diagOffset + extraX, y: centerY + diagOffset + 5, anchor: 'start' },
                { name: 'bottom-left', x: centerX - diagOffset - extraX, y: centerY + diagOffset + 5, anchor: 'end' },
                { name: 'top-left', x: centerX - diagOffset - extraX, y: centerY - diagOffset, anchor: 'end' }
            ];

            return [...card, ...diag];
        }

        function hasCollision(textElement, obstacles, ignoreCircle) {
            try {
                const rawBBox = textElement.getBBox();
                const pad = 2;
                const textBBox = {
                    x: rawBBox.x + pad,
                    y: rawBBox.y + pad,
                    width: Math.max(0, rawBBox.width - pad * 2),
                    height: Math.max(0, rawBBox.height - pad * 2)
                };

                for (const obs of obstacles) {
                    if (obs.isCircle && obs.ref === ignoreCircle) continue;

                    if (rectanglesOverlap(textBBox, obs)) {
                        return true;
                    }
                }
                return false;
            } catch (e) {
                return false;
            }
        }

        function isOutOfBounds(textElement, bounds) {
            if (!bounds) return false;
            try {
                const bbox = textElement.getBBox();
                const margin = 5;
                if (bbox.x < bounds.x + margin ||
                    bbox.y < bounds.y + margin ||
                    (bbox.x + bbox.width) > (bounds.x + bounds.width - margin) ||
                    (bbox.y + bbox.height) > (bounds.y + bounds.height - margin)) {
                    return true;
                }
                return false;
            } catch (e) {
                return false;
            }
        }

        function findBestPosition(textElement, centerX, centerY, radius, obstacles, fullText, bounds, currentCircle, manualDirection) {
            const positions = getPositionOptions(centerX, centerY, radius);
            const truncatedText = truncateText(fullText, 35);

            if (manualDirection !== undefined && manualDirection !== null) {
                const directionMap = {
                    0: 'right',
                    1: 'bottom-right',
                    2: 'below',
                    3: 'bottom-left',
                    4: 'left',
                    5: 'top-left',
                    6: 'above',
                    7: 'top-right'
                };

                const dir = directionMap[manualDirection];
                const manualPos = positions.find(p => p.name === dir);
                if (manualPos) {
                    textElement.textContent = fullText;
                    textElement.setAttribute('x', manualPos.x);
                    textElement.setAttribute('y', manualPos.y);
                    textElement.setAttribute('text-anchor', manualPos.anchor);

                    const isColliding = hasCollision(textElement, obstacles, currentCircle);
                    return { ...manualPos, text: fullText, hasCollision: isColliding, isManual: true };
                }
            }

            let hasCollisionWithFull = false;

            textElement.textContent = fullText;
            for (const pos of positions) {
                textElement.setAttribute('x', pos.x);
                textElement.setAttribute('y', pos.y);
                textElement.setAttribute('text-anchor', pos.anchor);

                if (!hasCollision(textElement, obstacles, currentCircle) && !isOutOfBounds(textElement, bounds)) {
                    return { ...pos, text: fullText, hasCollision: false };
                }
            }

            hasCollisionWithFull = true;

            hasCollisionWithFull = true;

            textElement.textContent = truncatedText;
            for (const pos of positions) {
                textElement.setAttribute('x', pos.x);
                textElement.setAttribute('y', pos.y);
                textElement.setAttribute('text-anchor', pos.anchor);

                if (!hasCollision(textElement, obstacles, currentCircle) && !isOutOfBounds(textElement, bounds)) {
                    return { ...pos, text: truncatedText, hasCollision: hasCollisionWithFull };
                }
            }

            return { ...positions[0], text: truncatedText, hasCollision: true };
        }

        function getBoundData(element) {
            if (element.__data__) {
                return element.__data__;
            }

            let parent = element.parentElement;
            while (parent) {
                if (parent.__data__) {
                    return parent.__data__;
                }
                parent = parent.parentElement;
            }

            return null;
        }

        function findMatchingDataPoint(circle) {
            const bound = circle.__data__ || d3.select(circle).datum();
            if (bound) return bound;
            console.warn('No data bound to circle:', circle);
            return null;
        }

        var data = [
            {
                "geo": "European Union (EU)",
                "domain": "Advanced Biologics & Cell Therapies",
                "share_p1": 15.78,
                "share_p2": 12.4,
                "growth": -3.38,
                "color": "#BC8F8F",
                "id": "Advanced Biologics & Cell Therapies",
                "x": 15.78,
                "y": 12.4,
                "delta": -21.42,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Air and Water Quality Sensors",
                "share_p1": 23.15,
                "share_p2": 21.08,
                "growth": -2.07,
                "color": "#A3BAA3",
                "id": "Air and Water Quality Sensors",
                "x": 23.15,
                "y": 21.08,
                "delta": -8.94,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "AMR Solutions",
                "share_p1": 22.26,
                "share_p2": 19.32,
                "growth": -2.94,
                "color": "#CFC8C8",
                "id": "AMR Solutions",
                "x": 22.26,
                "y": 19.32,
                "delta": -13.21,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Artificial Intelligence",
                "share_p1": 10.51,
                "share_p2": 10.75,
                "growth": 0.24,
                "color": "#6D9D6D",
                "id": "Artificial Intelligence",
                "x": 10.51,
                "y": 10.75,
                "delta": 2.28,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Autonomous Tractors and Drones",
                "share_p1": 19.29,
                "share_p2": 17.74,
                "growth": -1.55,
                "color": "#9CB69C",
                "id": "Autonomous Tractors and Drones",
                "x": 19.29,
                "y": 17.74,
                "delta": -8.04,
                "value": 1,
                "labelDirection": 6
            },
            {
                "geo": "European Union (EU)",
                "domain": "Biosensors and Wearables",
                "share_p1": 18.35,
                "share_p2": 16.34,
                "growth": -2.01,
                "color": "#C1C9C1",
                "id": "Biosensors and Wearables",
                "x": 18.35,
                "y": 16.34,
                "delta": -10.95,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Blockchain",
                "share_p1": 9.48,
                "share_p2": 9.48,
                "growth": 0,
                "color": "#74A174",
                "id": "Blockchain",
                "x": 9.48,
                "y": 9.48,
                "delta": 0,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Breeding",
                "share_p1": 20.3,
                "share_p2": 17.26,
                "growth": -3.04,
                "color": "#CCBDBD",
                "id": "Breeding",
                "x": 20.3,
                "y": 17.26,
                "delta": -14.98,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Climate-smart technologies",
                "share_p1": 23.75,
                "share_p2": 18.85,
                "growth": -4.9,
                "color": "#BE9696",
                "id": "Climate-smart technologies",
                "x": 23.75,
                "y": 18.85,
                "delta": -20.63,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Data Analytics",
                "share_p1": 12.6,
                "share_p2": 11.33,
                "growth": -1.27,
                "color": "#B0C1B0",
                "id": "Data Analytics",
                "x": 12.6,
                "y": 11.33,
                "delta": -10.08,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Digital Therapeutics",
                "share_p1": 19.16,
                "share_p2": 16.09,
                "growth": -3.07,
                "color": "#C9B7B7",
                "id": "Digital Therapeutics",
                "x": 19.16,
                "y": 16.09,
                "delta": -16.02,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "DNA Technology - Genetically modified organisms (GMOs)",
                "share_p1": 16.49,
                "share_p2": 12.97,
                "growth": -3.52,
                "color": "#BC9090",
                "id": "DNA Technology - Genetically modified organisms (GMOs)",
                "x": 16.49,
                "y": 12.97,
                "delta": -21.35,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Electronic Health Records",
                "share_p1": 19.43,
                "share_p2": 14.88,
                "growth": -4.55,
                "color": "#B67E7E",
                "id": "Electronic Health Records",
                "x": 19.43,
                "y": 14.88,
                "delta": -23.42,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Fertilisers and Pesticides",
                "share_p1": 23.02,
                "share_p2": 21.31,
                "growth": -1.71,
                "color": "#97B397",
                "id": "Fertilisers and Pesticides",
                "x": 23.02,
                "y": 21.31,
                "delta": -7.43,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Geographic Information Systems (GIS) and Remote Sensing",
                "share_p1": 19.07,
                "share_p2": 16.35,
                "growth": -2.72,
                "color": "#CDC2C2",
                "id": "Geographic Information Systems (GIS) and Remote Sensing",
                "x": 19.07,
                "y": 16.35,
                "delta": -14.26,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Imaging Technology",
                "share_p1": 15.83,
                "share_p2": 13.99,
                "growth": -1.84,
                "color": "#D2D1D1",
                "id": "Imaging Technology",
                "x": 15.83,
                "y": 13.99,
                "delta": -11.62,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Infectious Diseases Tests",
                "share_p1": 16.95,
                "share_p2": 13.8,
                "growth": -3.15,
                "color": "#C3A5A5",
                "id": "Infectious Diseases Tests",
                "x": 16.95,
                "y": 13.8,
                "delta": -18.58,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Internet Of Things (IOT)",
                "share_p1": 17.7,
                "share_p2": 14.16,
                "growth": -3.54,
                "color": "#C09B9B",
                "id": "Internet Of Things (IOT)",
                "x": 17.7,
                "y": 14.16,
                "delta": -20,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Livestock technologies",
                "share_p1": 21.84,
                "share_p2": 19.55,
                "growth": -2.29,
                "color": "#B7C4B7",
                "id": "Livestock technologies",
                "x": 21.84,
                "y": 19.55,
                "delta": -10.49,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Nanotechnologies",
                "share_p1": 15.56,
                "share_p2": 13.62,
                "growth": -1.94,
                "color": "#D1CCCC",
                "id": "Nanotechnologies",
                "x": 15.56,
                "y": 13.62,
                "delta": -12.47,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Natural Language Processing",
                "share_p1": 9.22,
                "share_p2": 8.09,
                "growth": -1.13,
                "color": "#D1CDCD",
                "id": "Natural Language Processing",
                "x": 9.22,
                "y": 8.09,
                "delta": -12.26,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Plant Tissue Culture",
                "share_p1": 18.1,
                "share_p2": 16.81,
                "growth": -1.29,
                "color": "#95B295",
                "id": "Plant Tissue Culture",
                "x": 18.1,
                "y": 16.81,
                "delta": -7.13,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Precision agriculture",
                "share_p1": 20.84,
                "share_p2": 19.07,
                "growth": -1.77,
                "color": "#9FB89F",
                "id": "Precision agriculture",
                "x": 20.84,
                "y": 19.07,
                "delta": -8.49,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Prosthetics",
                "share_p1": 18.86,
                "share_p2": 17.76,
                "growth": -1.1,
                "color": "#8DAE8D",
                "id": "Prosthetics",
                "x": 18.86,
                "y": 17.76,
                "delta": -5.83,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Rehab Robotics",
                "share_p1": 19.39,
                "share_p2": 17.63,
                "growth": -1.76,
                "color": "#A5BBA5",
                "id": "Rehab Robotics",
                "x": 19.39,
                "y": 17.63,
                "delta": -9.08,
                "value": 1,
                "labelDirection": 0
            },
            {
                "geo": "European Union (EU)",
                "domain": "Robots",
                "share_p1": 23.44,
                "share_p2": 18.75,
                "growth": -4.69,
                "color": "#C09B9B",
                "id": "Robots",
                "x": 23.44,
                "y": 18.75,
                "delta": -20.01,
                "value": 1,
                "labelDirection": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Supply Chain Management",
                "share_p1": 11.53,
                "share_p2": 11.65,
                "growth": 0.12,
                "color": "#709F70",
                "id": "Supply Chain Management",
                "x": 11.53,
                "y": 11.65,
                "delta": 1.04,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Surgical Devices",
                "share_p1": 17.67,
                "share_p2": 16.63,
                "growth": -1.04,
                "color": "#8DAE8D",
                "id": "Surgical Devices",
                "x": 17.67,
                "y": 16.63,
                "delta": -5.89,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Telemedicine",
                "share_p1": 17.63,
                "share_p2": 12.32,
                "growth": -5.31,
                "color": "darkred",
                "id": "Telemedicine",
                "x": 17.63,
                "y": 12.32,
                "delta": -30.12,
                "value": 1,
                "labelDirection": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Vaccines",
                "share_p1": 17.19,
                "share_p2": 14.26,
                "growth": -2.93,
                "color": "#C7B0B0",
                "id": "Vaccines",
                "x": 17.19,
                "y": 14.26,
                "delta": -17.04,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Vector Control",
                "share_p1": 21.66,
                "share_p2": 18.49,
                "growth": -3.17,
                "color": "#CCBFBF",
                "id": "Vector Control",
                "x": 21.66,
                "y": 18.49,
                "delta": -14.64,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Water And Sanitation Hygiene Technologies",
                "share_p1": 21.58,
                "share_p2": 19.76,
                "growth": -1.82,
                "color": "#9FB89F",
                "id": "Water And Sanitation Hygiene Technologies",
                "x": 21.58,
                "y": 19.76,
                "delta": -8.43,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Water management",
                "share_p1": 22.29,
                "share_p2": 20.44,
                "growth": -1.85,
                "color": "#9EB79E",
                "id": "Water management",
                "x": 22.29,
                "y": 20.44,
                "delta": -8.3,
                "value": 1
            }
        ]
            ;

        const xDomain = [8, 26];
        const yDomain = [7, 22];
        const xAxisName = "Previous Period (t-1)";
        const yAxisName = "Current Period (t)";
        const legendPosText = "Growth > Median";
        const legendNegText = "Growth < Median";
        const footnoteText = "Color represents growth or decline between periods. Green does not necessarily indicate positive growth.";
        const tooltipFields = [
            { label: "t-1", key: "x" },
            { label: "t", key: "y" },
            { label: "Growth/decline", key: "delta" },
            { label: "ID", key: "id" }
        ];

        document.addEventListener("DOMContentLoaded", () => {
            try {
                const legendItems = document.querySelectorAll('.legend-item span:last-child');
                if (legendItems.length >= 2) {
                    legendItems[0].textContent = legendPosText;
                    legendItems[1].textContent = legendNegText;
                }
                const footerDiv = document.getElementById('chart-footnote');
                if (footerDiv) footerDiv.innerHTML = footnoteText;
            } catch (e) { console.warn("Could not update legend/footnote", e); }
        });

        const xVals = data.map(d => d.x);
        const yVals = data.map(d => d.y);
        const medianX = median(xVals);
        const medianY = median(yVals);
        const minY = yDomain[0];
        const maxY = yDomain[1];

        let customLabels = [];
        let isUpdating = false;
        let hoveringElements = new Set();

        new d3plus.Plot()
            .select("#chart")
            .data(data)
            .annotations([{
                data: [{ id: "Trend", x: medianX, y: minY },
                { id: "Trend", x: medianX, y: maxY },
                { id: "Baseline", x: xDomain[0], y: medianY },
                { id: "Baseline", x: xDomain[1], y: medianY }], shape: "Line", stroke: "#c3c3c3", strokeDasharray: "10", strokeWidth: 2
            }])
            .groupBy(["parent", "id"])
            .tooltipConfig({
                body: d => {
                    const tableRows = tooltipFields.map(f => {
                        const val = d[f.key] !== undefined ? d[f.key] : 'N/A';
                        return `<tr><td class='title'>${f.label}:</td><td class='data'>${val}</td></tr>`;
                    }).join('');
                    return `<table class='tooltip-table'>${tableRows}</table>`;
                },
                title: d => d.id
            })
            .size("value")
            .sizeMin(12.75)
            .sizeMax(12.75)
            .color("color")
            .label("")
            .shapeConfig({
                Circle: {
                    labelConfig: { fontSize: 0 }
                }
            })
            .yConfig({
                title: yAxisName,
                titleConfig: { fontSize: () => 16 },
                gridConfig: { stroke: "transparent" },
                shapeConfig: { labelConfig: { fontSize: () => 16 } }
            })
            .yDomain(yDomain)
            .xDomain(xDomain)
            .xConfig({
                title: xAxisName,
                titleConfig: { fontSize: () => 16 },
                gridConfig: { stroke: "transparent" },
                shapeConfig: { labelConfig: { fontSize: () => 16 } }
            })
            .legend(false)
            .downloadButton(false)
            .render();

        setTimeout(() => {
            initializeCustomLabels();
            startPositionUpdater();
        }, 500);

        function initializeCustomLabels() {
            const svg = document.querySelector('#chart svg');
            if (!svg) {
                setTimeout(initializeCustomLabels, 100);
                return;
            }

            const circles = svg.querySelectorAll('circle');
            console.log('Found circles:', circles.length);

            circles.forEach((circle, index) => {
                let matchingData = findMatchingDataPoint(circle);

                if (matchingData) {
                    const originalData = data.find(d => d.id === matchingData.id);
                    if (originalData) {
                        matchingData = originalData;
                    }

                    console.log('Circle', index, 'matched to data:', matchingData.id, 'Direction:', matchingData.labelDirection);

                    const fullText = matchingData.id;

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('class', 'custom-label');
                    text.setAttribute('data-id', matchingData.id);
                    text.setAttribute('text-anchor', 'start');
                    text.setAttribute('font-family', 'Arial, Helvetica, sans-serif');
                    text.setAttribute('font-size', '13');
                    if (matchingData.labelColor) {
                        text.setAttribute('fill', matchingData.labelColor);
                        text.style.fill = matchingData.labelColor;
                    } else {
                        text.setAttribute('fill', '#000');
                    }
                    text.setAttribute('font-weight', 'normal');
                    text.textContent = fullText;

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('class', 'connector-line');

                    svg.appendChild(line);
                    svg.appendChild(text);

                    customLabels.push({
                        circle: circle,
                        text: text,
                        line: line,
                        data: matchingData,
                        fullText: fullText,
                        defaultText: fullText,
                        savedPosition: null
                    });

                    circle.addEventListener('mouseenter', () => {
                        hoveringElements.add(text);

                        const labelData = customLabels.find(l => l.circle === circle);
                        if (labelData) {
                            labelData.savedPosition = {
                                x: text.getAttribute('x'),
                                y: text.getAttribute('y'),
                                anchor: text.getAttribute('text-anchor'),
                                content: text.textContent
                            };
                        }

                        text.classList.add('hover');
                        text.textContent = fullText;

                        console.log('Hovering over:', matchingData.id);
                    });

                    circle.addEventListener('mouseleave', () => {
                        hoveringElements.delete(text);

                        text.classList.remove('hover');

                        const labelData = customLabels.find(l => l.circle === circle);
                        if (labelData && labelData.savedPosition) {
                            text.setAttribute('x', labelData.savedPosition.x);
                            text.setAttribute('y', labelData.savedPosition.y);
                            text.setAttribute('text-anchor', labelData.savedPosition.anchor);
                            text.textContent = labelData.savedPosition.content;
                        }
                    });
                } else {
                    console.log('Circle', index, 'could not be matched to data');
                }
            });

            updateLabelPositions();
        }

        function updateLabelPositions() {
            if (isUpdating) return;
            isUpdating = true;

            const svg = document.querySelector('#chart svg');
            if (!svg) {
                isUpdating = false;
                return;
            }

            const chartDiv = document.getElementById('chart');
            const width = chartDiv ? chartDiv.clientWidth : window.innerWidth;
            let currentFontSize = 13;
            if (width < 600) currentFontSize = 9;
            else if (width < 900) currentFontSize = 11;

            customLabels.forEach(({ text }) => {
                if (text) {
                    text.setAttribute('font-size', currentFontSize);
                    text.style.fontSize = currentFontSize + 'px';
                }
            });

            const circlePositions = [];

            customLabels.forEach(({ circle, text }) => {
                if (circle && text) {
                    const bbox = circle.getBoundingClientRect();
                    const svgRect = svg.getBoundingClientRect();

                    const svgPoint = svg.createSVGPoint();
                    svgPoint.x = bbox.left + bbox.width / 2 - svgRect.left;
                    svgPoint.y = bbox.top + bbox.height / 2 - svgRect.top;

                    const screenCTM = svg.getScreenCTM();
                    if (screenCTM) {
                        const svgCoords = svgPoint.matrixTransform(screenCTM.inverse());
                        circlePositions.push({
                            circle: circle,
                            coords: svgCoords
                        });
                    }
                }
            });

            const obstacles = circlePositions.map(c => {
                const r = parseFloat(c.circle.getAttribute('r')) || 7.5;
                return {
                    x: c.coords.x - r,
                    y: c.coords.y - r,
                    width: r * 2,
                    height: r * 2,
                    isCircle: true,
                    ref: c.circle
                };
            });

            let bounds = null;
            if (svg) {
                try {
                    const screenCTM = svg.getScreenCTM();
                    if (screenCTM) {
                        const inverseCTM = screenCTM.inverse();
                        const rect = svg.getBoundingClientRect();

                        const p1 = svg.createSVGPoint();
                        p1.x = rect.left;
                        p1.y = rect.top;
                        const min = p1.matrixTransform(inverseCTM);

                        const p2 = svg.createSVGPoint();
                        p2.x = rect.right;
                        p2.y = rect.bottom;
                        const max = p2.matrixTransform(inverseCTM);

                        bounds = {
                            x: min.x,
                            y: min.y,
                            width: max.x - min.x,
                            height: max.y - min.y
                        };
                    }
                } catch (e) {
                    console.log('Error calculating bounds', e);
                }
            }

            customLabels.forEach((labelData) => {
                const { circle, text, line, fullText } = labelData;

                if (hoveringElements.has(text)) {
                    return;
                }

                if (circle && text) {
                    const circleData = circlePositions.find(cp => cp.circle === circle);
                    if (circleData) {
                        const r = parseFloat(circle.getAttribute('r')) || 7.5;
                        const bestPosition = findBestPosition(
                            text,
                            circleData.coords.x,
                            circleData.coords.y,
                            r,
                            obstacles,
                            fullText,
                            bounds,
                            circle,
                            labelData.data ? labelData.data.labelDirection : null
                        );

                        text.setAttribute('x', bestPosition.x);
                        text.setAttribute('y', bestPosition.y);
                        text.setAttribute('text-anchor', bestPosition.anchor);
                        text.textContent = bestPosition.text;
                        labelData.defaultText = bestPosition.text;

                        if (bestPosition.hasCollision && !bestPosition.isManual) {
                            text.classList.add('collision');
                            text.setAttribute('opacity', '0.3');
                        } else {
                            text.classList.remove('collision');
                            text.setAttribute('opacity', '1');
                        }

                        if (line) {
                            line.setAttribute('opacity', (bestPosition.hasCollision && !bestPosition.isManual) ? '0.2' : '0.5');

                            const cx = circleData.coords.x;
                            const cy = circleData.coords.y;
                            let lx1, ly1, lx2, ly2;

                            const name = bestPosition.name;

                            lx1 = cx; ly1 = cy;
                            lx2 = bestPosition.x; ly2 = bestPosition.y;

                            if (name === 'right') {
                                lx1 = cx + r; ly1 = cy;
                                lx2 = bestPosition.x - 2; ly2 = cy;
                            } else if (name === 'left') {
                                lx1 = cx - r; ly1 = cy;
                                lx2 = bestPosition.x + 2; ly2 = cy;
                            } else if (name === 'above') {
                                lx1 = cx; ly1 = cy - r;
                                lx2 = cx; ly2 = bestPosition.y + 2;
                            } else if (name === 'below') {
                                lx1 = cx; ly1 = cy + r;
                                lx2 = cx; ly2 = bestPosition.y - 12;
                            } else if (name === 'top-right') {
                                lx1 = cx + r * 0.7; ly1 = cy - r * 0.7;
                                lx2 = bestPosition.x - 2; ly2 = bestPosition.y - 4;
                            } else if (name === 'bottom-right') {
                                lx1 = cx + r * 0.7; ly1 = cy + r * 0.7;
                                lx2 = bestPosition.x - 2; ly2 = bestPosition.y - 5;
                            } else if (name === 'bottom-left') {
                                lx1 = cx - r * 0.7; ly1 = cy + r * 0.7;
                                lx2 = bestPosition.x + 2; ly2 = bestPosition.y - 5;
                            } else if (name === 'top-left') {
                                lx1 = cx - r * 0.7; ly1 = cy - r * 0.7;
                                lx2 = bestPosition.x + 2; ly2 = bestPosition.y - 4;
                            }

                            line.setAttribute('x1', lx1);
                            line.setAttribute('y1', ly1);
                            line.setAttribute('x2', lx2);
                            line.setAttribute('y2', ly2);
                        }

                        const bbox = text.getBBox();
                        obstacles.push({
                            x: bbox.x,
                            y: bbox.y,
                            width: bbox.width,
                            height: bbox.height,
                            isCircle: false
                        });
                    }
                }
            });

            isUpdating = false;
        }

        function startPositionUpdater() {
            function updateLoop() {
                updateLabelPositions();
                requestAnimationFrame(updateLoop);
            }

            updateLoop();

            const chartElement = document.getElementById('chart');
            if (chartElement) {
                chartElement.addEventListener('wheel', updateLabelPositions, { passive: true });
                chartElement.addEventListener('mousedown', updateLabelPositions);
                chartElement.addEventListener('mousemove', updateLabelPositions);
                chartElement.addEventListener('mouseup', updateLabelPositions);
            }
        }
    </script>
    <script>
        document.addEventListener('keydown', function (e) {
            if (e.key === 'd' || e.key === 'D') {
                downloadSnapshot();
            }
        });

        function downloadSnapshot() {
            const clone = document.documentElement.cloneNode(true);
            const scripts = clone.querySelectorAll('script');
            scripts.forEach(script => script.remove());
            const tooltips = clone.querySelectorAll('.d3plus-tooltip');
            tooltips.forEach(t => t.remove());
            const hoverLabels = clone.querySelectorAll('.custom-label.hover');
            hoverLabels.forEach(label => {
                label.classList.remove('hover');
                label.style.opacity = "";
                label.style.fontSize = "";
                label.style.fontWeight = "";
            });

            const htmlContent = clone.outerHTML;
            const blob = new Blob(['<!doctype html>', htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'snapshot.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>

</html>