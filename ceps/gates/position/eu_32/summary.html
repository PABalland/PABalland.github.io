<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <script src="https://www.paballand.com/js/d3plus-plot.v0.9.full.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, Helvetica, sans-serif;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #chart {
            flex: 1 1 auto;
        }

        .footer-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            width: 100%;
            padding: 0 10px 10px 10px;
            box-sizing: border-box;
            min-height: 40px;
        }

        .legend {
            display: flex;
            justify-content: center;
            padding: 12px 0;
            z-index: 2;
            white-space: nowrap;
        }

        #chart-footnote {
            position: absolute;
            right: 10px;
            bottom: 12px;
            text-align: right;
            font-size: 11px;
            color: #888;
            font-style: italic;
            z-index: 1;
            pointer-events: none;
        }

        @media (max-width: 850px) {
            .footer-wrapper {
                flex-direction: column;
                align-items: center;
            }

            #chart-footnote {
                position: static;
                margin-top: 5px;
                text-align: center;
                max-width: 100%;
            }
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 24px;
            font-size: 14px;
        }

        .box {
            width: 14px;
            height: 14px;
            margin-right: 10px;
            border: none;
        }

        .pos {
            background: #2d7c2d;
        }

        .neg {
            background: #8B1A0F;
        }

        .tooltip-table {
            width: 100%;
        }

        .tooltip-table .data {
            text-align: right;
        }

        .tooltip-footer {
            opacity: .5;
        }

        tspan {
            font-family: "Helvetica", "Arial", sans-serif;
            font-size: 100px;
            font-style: oblique;
        }

        .custom-label {
            font-family: Arial, Helvetica, sans-serif;
            font-size: 13px;
            fill: #000;
            opacity: 1;
            font-weight: normal;
            transition: opacity 0.4s ease, font-size 0.4s ease, font-weight 0.4s ease;
            pointer-events: none;
            transform-origin: center;
        }

        .custom-label.collision {
            opacity: 0.3;
        }

        .custom-label.hover {
            opacity: 1 !important;
            font-size: 16px !important;
            font-weight: bold !important;
        }

        .custom-label,
        text.custom-label {
            font-family: Arial, Helvetica, sans-serif !important;
            font-size: 13px;
            fill: #000 !important;
            stroke: none !important;
            font-weight: normal !important;
        }

        .connector-line {
            stroke: #000;
            stroke-width: 1px;
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="chart"></div>
        <div class="footer-wrapper">
            <div class="legend">
                <div class="legend-item"><span class="box pos"></span><span>Investment RCA &gt; 1</span></div>
                <div class="legend-item"><span class="box neg"></span><span>Investment RCA &lt; 1</span></div>
            </div>
            <div id="chart-footnote"></div>
        </div>
    </div>
    <script>
        function median(v) {
            if (!v.length) throw new Error("empty");
            v = [...v].sort((a, b) => a - b);
            const h = Math.floor(v.length / 2);
            return v.length % 2 ? v[h] : (v[h - 1] + v[h]) / 2;
        }

        function truncateText(text, maxLength = 35) {
            if (text.length <= maxLength) {
                return text;
            }
            return text.substring(0, maxLength) + "...";
        }

        function rectanglesOverlap(rect1, rect2) {
            return !(rect1.x + rect1.width < rect2.x ||
                rect2.x + rect2.width < rect1.x ||
                rect1.y + rect1.height < rect2.y ||
                rect2.y + rect2.height < rect1.y);
        }

        function getPositionOptions(centerX, centerY, radius, padding = 8) {
            const card = [
                { name: 'right', x: centerX + radius + padding, y: centerY + 5, anchor: 'start' },
                { name: 'left', x: centerX - radius - padding, y: centerY + 5, anchor: 'end' },
                { name: 'below', x: centerX, y: centerY + radius + padding + 10, anchor: 'middle' },
                { name: 'above', x: centerX, y: centerY - radius - padding, anchor: 'middle' }
            ];

            const diagPad = padding;
            const diagOffset = (radius + diagPad) * 0.707;
            const extraX = 4;

            const diag = [
                { name: 'top-right', x: centerX + diagOffset + extraX, y: centerY - diagOffset, anchor: 'start' },
                { name: 'bottom-right', x: centerX + diagOffset + extraX, y: centerY + diagOffset + 5, anchor: 'start' },
                { name: 'bottom-left', x: centerX - diagOffset - extraX, y: centerY + diagOffset + 5, anchor: 'end' },
                { name: 'top-left', x: centerX - diagOffset - extraX, y: centerY - diagOffset, anchor: 'end' }
            ];

            return [...card, ...diag];
        }

        function hasCollision(textElement, obstacles, ignoreCircle) {
            try {
                const rawBBox = textElement.getBBox();
                const pad = 2;
                const textBBox = {
                    x: rawBBox.x + pad,
                    y: rawBBox.y + pad,
                    width: Math.max(0, rawBBox.width - pad * 2),
                    height: Math.max(0, rawBBox.height - pad * 2)
                };

                for (const obs of obstacles) {
                    if (obs.isCircle && obs.ref === ignoreCircle) continue;

                    if (rectanglesOverlap(textBBox, obs)) {
                        return true;
                    }
                }
                return false;
            } catch (e) {
                return false;
            }
        }

        function isOutOfBounds(textElement, bounds) {
            if (!bounds) return false;
            try {
                const bbox = textElement.getBBox();
                const margin = 5;
                if (bbox.x < bounds.x + margin ||
                    bbox.y < bounds.y + margin ||
                    (bbox.x + bbox.width) > (bounds.x + bounds.width - margin) ||
                    (bbox.y + bbox.height) > (bounds.y + bounds.height - margin)) {
                    return true;
                }
                return false;
            } catch (e) {
                return false;
            }
        }

        function findBestPosition(textElement, centerX, centerY, radius, obstacles, fullText, bounds, currentCircle, manualDirection) {
            const positions = getPositionOptions(centerX, centerY, radius);
            const truncatedText = truncateText(fullText, 35);

            if (manualDirection !== undefined && manualDirection !== null) {
                const directionMap = {
                    0: 'right',
                    1: 'bottom-right',
                    2: 'below',
                    3: 'bottom-left',
                    4: 'left',
                    5: 'top-left',
                    6: 'above',
                    7: 'top-right'
                };

                const dir = directionMap[manualDirection];
                const manualPos = positions.find(p => p.name === dir);
                if (manualPos) {
                    textElement.textContent = fullText;
                    textElement.setAttribute('x', manualPos.x);
                    textElement.setAttribute('y', manualPos.y);
                    textElement.setAttribute('text-anchor', manualPos.anchor);

                    const isColliding = hasCollision(textElement, obstacles, currentCircle);
                    return { ...manualPos, text: fullText, hasCollision: isColliding, isManual: true };
                }
            }

            let hasCollisionWithFull = false;

            textElement.textContent = fullText;
            for (const pos of positions) {
                textElement.setAttribute('x', pos.x);
                textElement.setAttribute('y', pos.y);
                textElement.setAttribute('text-anchor', pos.anchor);

                if (!hasCollision(textElement, obstacles, currentCircle) && !isOutOfBounds(textElement, bounds)) {
                    return { ...pos, text: fullText, hasCollision: false };
                }
            }

            hasCollisionWithFull = true;

            hasCollisionWithFull = true;

            textElement.textContent = truncatedText;
            for (const pos of positions) {
                textElement.setAttribute('x', pos.x);
                textElement.setAttribute('y', pos.y);
                textElement.setAttribute('text-anchor', pos.anchor);

                if (!hasCollision(textElement, obstacles, currentCircle) && !isOutOfBounds(textElement, bounds)) {
                    return { ...pos, text: truncatedText, hasCollision: hasCollisionWithFull };
                }
            }

            return { ...positions[0], text: truncatedText, hasCollision: true };
        }

        function getBoundData(element) {
            if (element.__data__) {
                return element.__data__;
            }

            let parent = element.parentElement;
            while (parent) {
                if (parent.__data__) {
                    return parent.__data__;
                }
                parent = parent.parentElement;
            }

            return null;
        }

        function findMatchingDataPoint(circle) {
            const bound = circle.__data__ || d3.select(circle).datum();
            if (bound) return bound;
            console.warn('No data bound to circle:', circle);
            return null;
        }

        var data = [
            {
                "geo": "European Union (EU)",
                "domain": "Advanced Biologics & Cell Therapies",
                "regpat": 42.0924,
                "openalex": 100,
                "crunchbase": 92.7478,
                "color": "#B5C3B5",
                "id": "Advanced Biologics & Cell Therapies",
                "x": 42.0924,
                "y": 100,
                "value": 1,
                "labelDirection": 6
            },
            {
                "geo": "European Union (EU)",
                "domain": "Air and Water Quality Sensors",
                "regpat": 67.2252,
                "openalex": 48.4591,
                "crunchbase": 90.73,
                "color": "#BDC8BD",
                "id": "Air and Water Quality Sensors",
                "x": 67.2252,
                "y": 48.4591,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "AMR Solutions",
                "regpat": 100,
                "openalex": 73.1371,
                "crunchbase": 88.1187,
                "color": "#D3D2D2",
                "id": "AMR Solutions",
                "x": 100,
                "y": 73.1371,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Artificial Intelligence",
                "regpat": 6.5795,
                "openalex": 82.1527,
                "crunchbase": 85.5074,
                "color": "#D2CFCF",
                "id": "Artificial Intelligence",
                "x": 6.5795,
                "y": 82.1527,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Autonomous Tractors and Drones",
                "regpat": 89.0478,
                "openalex": 29.5078,
                "crunchbase": 88.9852,
                "color": "#C9CEC9",
                "id": "Autonomous Tractors and Drones",
                "x": 89.0478,
                "y": 29.5078,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Biosensors and Wearables",
                "regpat": 23.4982,
                "openalex": 87.8795,
                "crunchbase": 91.8813,
                "color": "#B8C5B8",
                "id": "Biosensors and Wearables",
                "x": 23.4982,
                "y": 87.8795,
                "value": 1,
                "labelDirection": 5
            },
            {
                "geo": "European Union (EU)",
                "domain": "Blockchain",
                "regpat": 0,
                "openalex": 30.6118,
                "crunchbase": 8.1187,
                "color": "#A14040",
                "id": "Blockchain",
                "x": 0,
                "y": 30.6118,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Breeding",
                "regpat": 61.2178,
                "openalex": 27.7369,
                "crunchbase": 81.1632,
                "color": "#D0CACA",
                "id": "Breeding",
                "x": 61.2178,
                "y": 27.7369,
                "value": 1,
                "labelDirection": 7
            },
            {
                "geo": "European Union (EU)",
                "domain": "Climate-smart technologies",
                "regpat": 57.3764,
                "openalex": 42.2953,
                "crunchbase": 84.0593,
                "color": "#D1CECE",
                "id": "Climate-smart technologies",
                "x": 57.3764,
                "y": 42.2953,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Data Analytics",
                "regpat": 0.5721,
                "openalex": 61.0166,
                "crunchbase": 83.7626,
                "color": "#D1CDCD",
                "id": "Data Analytics",
                "x": 0.5721,
                "y": 61.0166,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Digital Therapeutics",
                "regpat": 28.9743,
                "openalex": 70.2622,
                "crunchbase": 90.73,
                "color": "#BDC8BD",
                "id": "Digital Therapeutics",
                "x": 28.9743,
                "y": 70.2622,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "DNA Technology - Genetically modified organisms (GMOs)",
                "regpat": 42.0924,
                "openalex": 81.5087,
                "crunchbase": 97.9703,
                "color": "#A7BCA7",
                "id": "DNA Technology - Genetically modified organisms (GMOs)",
                "x": 42.0924,
                "y": 81.5087,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Electronic Health Records",
                "regpat": 16.3874,
                "openalex": 63.8684,
                "crunchbase": 89.5668,
                "color": "#C4CBC4",
                "id": "Electronic Health Records",
                "x": 16.3874,
                "y": 63.8684,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Fertilisers and Pesticides",
                "regpat": 43.727,
                "openalex": 1.5409,
                "crunchbase": 77.3887,
                "color": "#CEC5C5",
                "id": "Fertilisers and Pesticides",
                "x": 43.727,
                "y": 1.5409,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Geographic Information Systems (GIS) and Remote Sensing",
                "regpat": 78.1365,
                "openalex": 88.7764,
                "crunchbase": 84.3442,
                "color": "#D1CECE",
                "id": "Geographic Information Systems (GIS) and Remote Sensing",
                "x": 78.1365,
                "y": 88.7764,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Imaging Technology",
                "regpat": 43.1549,
                "openalex": 95.6072,
                "crunchbase": 90.4332,
                "color": "#BFC8BF",
                "id": "Imaging Technology",
                "x": 43.1549,
                "y": 95.6072,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Infectious Diseases Tests",
                "regpat": 45.3617,
                "openalex": 32.3827,
                "crunchbase": 89.5668,
                "color": "#C4CBC4",
                "id": "Infectious Diseases Tests",
                "x": 45.3617,
                "y": 32.3827,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Internet Of Things (IOT)",
                "regpat": 60.1144,
                "openalex": 26.4259,
                "crunchbase": 83.4777,
                "color": "#D1CDCD",
                "id": "Internet Of Things (IOT)",
                "x": 60.1144,
                "y": 26.4259,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Livestock technologies",
                "regpat": 72.6604,
                "openalex": 3.5189,
                "crunchbase": 81.1632,
                "color": "#D0CACA",
                "id": "Livestock technologies",
                "x": 72.6604,
                "y": 3.5189,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Nanotechnologies",
                "regpat": 38.7822,
                "openalex": 60.3496,
                "crunchbase": 87.5371,
                "color": "#D3D2D2",
                "id": "Nanotechnologies",
                "x": 38.7822,
                "y": 60.3496,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Natural Language Processing",
                "regpat": 1.1034,
                "openalex": 83.4867,
                "crunchbase": 25.6499,
                "color": "#B27272",
                "id": "Natural Language Processing",
                "x": 1.1034,
                "y": 83.4867,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Plant Tissue Culture",
                "regpat": 49.1622,
                "openalex": 6.8077,
                "crunchbase": 77.6855,
                "color": "#CEC6C6",
                "id": "Plant Tissue Culture",
                "x": 49.1622,
                "y": 6.8077,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Precision agriculture",
                "regpat": 56.273,
                "openalex": 23.781,
                "crunchbase": 82.0297,
                "color": "#D0CBCB",
                "id": "Precision agriculture",
                "x": 56.273,
                "y": 23.781,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Prosthetics",
                "regpat": 66.653,
                "openalex": 98.896,
                "crunchbase": 90.1484,
                "color": "#C0C9C0",
                "id": "Prosthetics",
                "x": 66.653,
                "y": 98.896,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Rehab Robotics",
                "regpat": 55.7417,
                "openalex": 94.2732,
                "crunchbase": 89.8516,
                "color": "#C2CAC2",
                "id": "Rehab Robotics",
                "x": 55.7417,
                "y": 94.2732,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Robots",
                "regpat": 97.7932,
                "openalex": 84.7976,
                "crunchbase": 91.5964,
                "color": "#B9C6B9",
                "id": "Robots",
                "x": 97.7932,
                "y": 84.7976,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Supply Chain Management",
                "regpat": 42.0924,
                "openalex": 81.0488,
                "crunchbase": 0,
                "color": "darkred",
                "id": "Supply Chain Management",
                "x": 42.0924,
                "y": 81.0488,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Surgical Devices",
                "regpat": 57.3764,
                "openalex": 86.5685,
                "crunchbase": 90.1484,
                "color": "#C0C9C0",
                "id": "Surgical Devices",
                "x": 57.3764,
                "y": 86.5685,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Telemedicine",
                "regpat": 27.8709,
                "openalex": 87.6725,
                "crunchbase": 83.9169,
                "color": "#D1CDCD",
                "id": "Telemedicine",
                "x": 27.8709,
                "y": 87.6725,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Vaccines",
                "regpat": 15.8562,
                "openalex": 70.0322,
                "crunchbase": 92.7478,
                "color": "#B5C3B5",
                "id": "Vaccines",
                "x": 15.8562,
                "y": 70.0322,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Vector Control",
                "regpat": 37.7197,
                "openalex": 26.8629,
                "crunchbase": 100,
                "color": "#A3B9A3",
                "id": "Vector Control",
                "x": 37.7197,
                "y": 26.8629,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Water And Sanitation Hygiene Technologies",
                "regpat": 65.0184,
                "openalex": 0,
                "crunchbase": 88.1187,
                "color": "#D3D2D2",
                "id": "Water And Sanitation Hygiene Technologies",
                "x": 65.0184,
                "y": 0,
                "value": 1
            },
            {
                "geo": "European Union (EU)",
                "domain": "Water management",
                "regpat": 60.6457,
                "openalex": 8.1417,
                "crunchbase": 91.2997,
                "color": "#BBC6BB",
                "id": "Water management",
                "x": 60.6457,
                "y": 8.1417,
                "value": 1
            }
        ];

        const xDomain = [-5, 115];
        const yDomain = [-5, 110];
        const xAxisName = "Technological Index";
        const yAxisName = "Scientific Index";
        const legendPosText = "Investment Index > median";
        const legendNegText = "Investment Index < median";
        const footnoteText = "Color indicates Investment Index.";
        const tooltipFields = [
            { label: "Investment Index", key: "crunchbase" },
            { label: "Technology Index", key: "regpat" },
            { label: "Scientific Index", key: "openalex" },
            { label: "ID", key: "id" }
        ];

        document.addEventListener("DOMContentLoaded", () => {
            try {
                const legendItems = document.querySelectorAll('.legend-item span:last-child');
                if (legendItems.length >= 2) {
                    legendItems[0].textContent = legendPosText;
                    legendItems[1].textContent = legendNegText;
                }
                const footerDiv = document.getElementById('chart-footnote');
                if (footerDiv) footerDiv.innerHTML = footnoteText;
            } catch (e) { console.warn("Could not update legend/footnote", e); }
        });

        const xVals = data.map(d => d.x);
        const yVals = data.map(d => d.y);
        const medianX = median(xVals);
        const medianY = median(yVals);
        const minY = yDomain[0];
        const maxY = yDomain[1];

        let customLabels = [];
        let isUpdating = false;
        let hoveringElements = new Set();

        new d3plus.Plot()
            .select("#chart")
            .data(data)
            .annotations([{
                data: [{ id: "Trend", x: medianX, y: minY },
                { id: "Trend", x: medianX, y: maxY },
                { id: "Baseline", x: xDomain[0], y: medianY },
                { id: "Baseline", x: xDomain[1], y: medianY }], shape: "Line", stroke: "#c3c3c3", strokeDasharray: "10", strokeWidth: 2
            }])
            .groupBy(["parent", "id"])
            .tooltipConfig({
                body: d => {
                    const tableRows = tooltipFields.map(f => {
                        const val = d[f.key] !== undefined ? d[f.key] : 'N/A';
                        return `<tr><td class='title'>${f.label}:</td><td class='data'>${val}</td></tr>`;
                    }).join('');
                    return `<table class='tooltip-table'>${tableRows}</table>`;
                },
                title: d => d.id
            })
            .size("value")
            .sizeMin(12.75)
            .sizeMax(12.75)
            .color("color")
            .label("")
            .shapeConfig({
                Circle: {
                    labelConfig: { fontSize: 0 }
                }
            })
            .yConfig({
                title: yAxisName,
                titleConfig: { fontSize: () => 16 },
                gridConfig: { stroke: "transparent" },
                shapeConfig: { labelConfig: { fontSize: () => 16 } }
            })
            .yDomain(yDomain)
            .xDomain(xDomain)
            .xConfig({
                title: xAxisName,
                titleConfig: { fontSize: () => 16 },
                gridConfig: { stroke: "transparent" },
                shapeConfig: { labelConfig: { fontSize: () => 16 } }
            })
            .legend(false)
            .downloadButton(false)
            .render();

        setTimeout(() => {
            initializeCustomLabels();
            startPositionUpdater();
        }, 500);

        function initializeCustomLabels() {
            const svg = document.querySelector('#chart svg');
            if (!svg) {
                setTimeout(initializeCustomLabels, 100);
                return;
            }

            const circles = svg.querySelectorAll('circle');
            console.log('Found circles:', circles.length);

            circles.forEach((circle, index) => {
                let matchingData = findMatchingDataPoint(circle);

                if (matchingData) {
                    // Refresh data from global source to ensure we have all properties (e.g. labelDirection)
                    const originalData = data.find(d => d.id === matchingData.id);
                    if (originalData) {
                        matchingData = originalData;
                    }

                    console.log('Circle', index, 'matched to data:', matchingData.id, 'Direction:', matchingData.labelDirection);

                    const fullText = matchingData.id;

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('class', 'custom-label');
                    text.setAttribute('data-id', matchingData.id);
                    text.setAttribute('text-anchor', 'start');
                    text.setAttribute('font-family', 'Arial, Helvetica, sans-serif');
                    text.setAttribute('font-size', '13');
                    if (matchingData.labelColor) {
                        text.setAttribute('fill', matchingData.labelColor);
                        text.style.fill = matchingData.labelColor;
                    } else {
                        text.setAttribute('fill', '#000');
                    }
                    text.setAttribute('font-weight', 'normal');
                    text.textContent = fullText;

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('class', 'connector-line');

                    svg.appendChild(line);
                    svg.appendChild(text);

                    customLabels.push({
                        circle: circle,
                        text: text,
                        line: line,
                        data: matchingData,
                        fullText: fullText,
                        defaultText: fullText,
                        savedPosition: null
                    });

                    circle.addEventListener('mouseenter', () => {
                        hoveringElements.add(text);

                        const labelData = customLabels.find(l => l.circle === circle);
                        if (labelData) {
                            labelData.savedPosition = {
                                x: text.getAttribute('x'),
                                y: text.getAttribute('y'),
                                anchor: text.getAttribute('text-anchor'),
                                content: text.textContent
                            };
                        }

                        text.classList.add('hover');
                        text.textContent = fullText;

                        console.log('Hovering over:', matchingData.id);
                    });

                    circle.addEventListener('mouseleave', () => {
                        hoveringElements.delete(text);

                        text.classList.remove('hover');

                        const labelData = customLabels.find(l => l.circle === circle);
                        if (labelData && labelData.savedPosition) {
                            text.setAttribute('x', labelData.savedPosition.x);
                            text.setAttribute('y', labelData.savedPosition.y);
                            text.setAttribute('text-anchor', labelData.savedPosition.anchor);
                            text.textContent = labelData.savedPosition.content;
                        }
                    });
                } else {
                    console.log('Circle', index, 'could not be matched to data');
                }
            });

            updateLabelPositions();
        }

        function updateLabelPositions() {
            if (isUpdating) return;
            isUpdating = true;

            const svg = document.querySelector('#chart svg');
            if (!svg) {
                isUpdating = false;
                return;
            }

            const chartDiv = document.getElementById('chart');
            const width = chartDiv ? chartDiv.clientWidth : window.innerWidth;
            let currentFontSize = 13;
            if (width < 600) currentFontSize = 9;
            else if (width < 900) currentFontSize = 11;

            customLabels.forEach(({ text }) => {
                if (text) {
                    text.setAttribute('font-size', currentFontSize);
                    text.style.fontSize = currentFontSize + 'px';
                }
            });

            const circlePositions = [];

            customLabels.forEach(({ circle, text }) => {
                if (circle && text) {
                    const bbox = circle.getBoundingClientRect();
                    const svgRect = svg.getBoundingClientRect();

                    const svgPoint = svg.createSVGPoint();
                    svgPoint.x = bbox.left + bbox.width / 2 - svgRect.left;
                    svgPoint.y = bbox.top + bbox.height / 2 - svgRect.top;

                    const screenCTM = svg.getScreenCTM();
                    if (screenCTM) {
                        const svgCoords = svgPoint.matrixTransform(screenCTM.inverse());
                        circlePositions.push({
                            circle: circle,
                            coords: svgCoords
                        });
                    }
                }
            });

            const obstacles = circlePositions.map(c => {
                const r = parseFloat(c.circle.getAttribute('r')) || 7.5;
                return {
                    x: c.coords.x - r,
                    y: c.coords.y - r,
                    width: r * 2,
                    height: r * 2,
                    isCircle: true,
                    ref: c.circle
                };
            });

            let bounds = null;
            if (svg) {
                try {
                    const screenCTM = svg.getScreenCTM();
                    if (screenCTM) {
                        const inverseCTM = screenCTM.inverse();
                        const rect = svg.getBoundingClientRect();

                        const p1 = svg.createSVGPoint();
                        p1.x = rect.left;
                        p1.y = rect.top;
                        const min = p1.matrixTransform(inverseCTM);

                        const p2 = svg.createSVGPoint();
                        p2.x = rect.right;
                        p2.y = rect.bottom;
                        const max = p2.matrixTransform(inverseCTM);

                        bounds = {
                            x: min.x,
                            y: min.y,
                            width: max.x - min.x,
                            height: max.y - min.y
                        };
                    }
                } catch (e) {
                    console.log('Error calculating bounds', e);
                }
            }

            customLabels.forEach((labelData) => {
                const { circle, text, line, fullText } = labelData;

                if (hoveringElements.has(text)) {
                    return;
                }

                if (circle && text) {
                    const circleData = circlePositions.find(cp => cp.circle === circle);
                    if (circleData) {
                        const r = parseFloat(circle.getAttribute('r')) || 7.5;
                        const bestPosition = findBestPosition(
                            text,
                            circleData.coords.x,
                            circleData.coords.y,
                            r,
                            obstacles,
                            fullText,
                            bounds,
                            circle,
                            labelData.data ? labelData.data.labelDirection : null
                        );

                        text.setAttribute('x', bestPosition.x);
                        text.setAttribute('y', bestPosition.y);
                        text.setAttribute('text-anchor', bestPosition.anchor);
                        text.textContent = bestPosition.text;
                        labelData.defaultText = bestPosition.text;

                        if (bestPosition.hasCollision && !bestPosition.isManual) {
                            text.classList.add('collision');
                            text.setAttribute('opacity', '0.3');
                        } else {
                            text.classList.remove('collision');
                            text.setAttribute('opacity', '1');
                        }

                        if (line) {
                            line.setAttribute('opacity', (bestPosition.hasCollision && !bestPosition.isManual) ? '0.2' : '0.5');

                            const cx = circleData.coords.x;
                            const cy = circleData.coords.y;
                            let lx1, ly1, lx2, ly2;

                            const name = bestPosition.name;

                            lx1 = cx; ly1 = cy;
                            lx2 = bestPosition.x; ly2 = bestPosition.y;

                            if (name === 'right') {
                                lx1 = cx + r; ly1 = cy;
                                lx2 = bestPosition.x - 2; ly2 = cy;
                            } else if (name === 'left') {
                                lx1 = cx - r; ly1 = cy;
                                lx2 = bestPosition.x + 2; ly2 = cy;
                            } else if (name === 'above') {
                                lx1 = cx; ly1 = cy - r;
                                lx2 = cx; ly2 = bestPosition.y + 2;
                            } else if (name === 'below') {
                                lx1 = cx; ly1 = cy + r;
                                lx2 = cx; ly2 = bestPosition.y - 12;
                            } else if (name === 'top-right') {
                                lx1 = cx + r * 0.7; ly1 = cy - r * 0.7;
                                lx2 = bestPosition.x - 2; ly2 = bestPosition.y - 4;
                            } else if (name === 'bottom-right') {
                                lx1 = cx + r * 0.7; ly1 = cy + r * 0.7;
                                lx2 = bestPosition.x - 2; ly2 = bestPosition.y - 5;
                            } else if (name === 'bottom-left') {
                                lx1 = cx - r * 0.7; ly1 = cy + r * 0.7;
                                lx2 = bestPosition.x + 2; ly2 = bestPosition.y - 5;
                            } else if (name === 'top-left') {
                                lx1 = cx - r * 0.7; ly1 = cy - r * 0.7;
                                lx2 = bestPosition.x + 2; ly2 = bestPosition.y - 4;
                            }

                            line.setAttribute('x1', lx1);
                            line.setAttribute('y1', ly1);
                            line.setAttribute('x2', lx2);
                            line.setAttribute('y2', ly2);
                        }

                        const bbox = text.getBBox();
                        obstacles.push({
                            x: bbox.x,
                            y: bbox.y,
                            width: bbox.width,
                            height: bbox.height,
                            isCircle: false
                        });
                    }
                }
            });

            isUpdating = false;
        }

        function startPositionUpdater() {
            function updateLoop() {
                updateLabelPositions();
                requestAnimationFrame(updateLoop);
            }

            updateLoop();

            const chartElement = document.getElementById('chart');
            if (chartElement) {
                chartElement.addEventListener('wheel', updateLabelPositions, { passive: true });
                chartElement.addEventListener('mousedown', updateLabelPositions);
                chartElement.addEventListener('mousemove', updateLabelPositions);
                chartElement.addEventListener('mouseup', updateLabelPositions);
            }
        }
    </script>

</body>

</html>