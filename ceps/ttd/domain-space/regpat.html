<!doctype html>
<html>

<head>

    <meta charset="utf-8">
    <title>Forced Network</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            font-family: "Avenir Next", "Helvetica Neue", Arial, sans-serif;
            background: #f5f7fa;
        }

        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        #legend-container {
            flex: 0 0 5vh;
            max-height: 5vh;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: clamp(8px, 2vh, 16px) clamp(16px, 4vw, 32px);
            background: rgba(255, 255, 255, 0.96);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.07);
            order: 2;
        }

        .custom-legend {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: clamp(8px, 1.5vw, 16px);
            width: 100%;
            max-height: 100%;
            overflow: auto;
            scrollbar-width: thin;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #1b1d21;
            font-size: clamp(12px, 1.3vw, 16px);
            cursor: default;
            white-space: nowrap;
        }

        .legend-item.dim {
            opacity: 0.35;
        }

        .legend-square {
            width: clamp(12px, 1.2vw, 16px);
            height: clamp(12px, 1.2vw, 16px);
        }

        .legend-label {
            pointer-events: none;
        }

        svg.network {
            flex: 1 1 auto;
            width: 100%;
            height: 100%;
            display: block;
            cursor: move;
            background: #ffffff;
            order: 1;
        }

        .link {
            stroke: rgba(140, 150, 170, 0.45);
        }

        .link.highlighted {
            stroke: rgba(80, 90, 110, 0.9);
            stroke-width: 6px;
        }

        .link.dimmed {
            opacity: 0.2;
        }

        .node.dimmed {
            opacity: 0.25;
        }

        .node.highlighted circle {
            stroke-width: 3px;
        }

        .node.highlighted text {
            font-weight: 700;
        }

        .node circle {
            stroke: #ffffff;
            stroke-width: 2px;
        }

        .node text {
            font-weight: 400;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            font-family: "Helvetica Neue", Arial, sans-serif;
        }
    </style>

</head>

<body>

    <div id="legend-container">
        <div class="custom-legend" id="legend"></div>
    </div>

    <svg class="network"></svg>

    <script>

        var nodes = [{ "id": "Artificial Intelligence", "id2": 0, "x": 0.2806, "y": -0.6034, "color": "#365a94", "parent": "Intelligent Systems", "size": 1.5 }, { "id": "Blockchain Technologies", "id2": 1, "x": -0.5495, "y": -0.8424, "color": "#8cab79", "parent": "Digital Foundations & Trust", "size": 1.5 }, { "id": "Cloud Computing & Edge Computing", "id2": 2, "x": -1.0805, "y": -0.6635, "color": "#800020", "parent": "Compute & Infrastructure", "size": 1.5 }, { "id": "Computer Vision, Language Processing & Object Recognition", "id2": 3, "x": 0.9086, "y": -0.3133, "color": "#365a94", "parent": "Intelligent Systems", "size": 1.5 }, { "id": "Cybersecurity Technologies", "id2": 4, "x": -0.715, "y": -0.2128, "color": "#8cab79", "parent": "Digital Foundations & Trust", "size": 1.5 }, { "id": "Drones", "id2": 5, "x": 1.7068, "y": -0.8991, "color": "#365a94", "parent": "Intelligent Systems", "size": 1.5 }, { "id": "Generative AI", "id2": 8, "x": 0.3516, "y": -0.0713, "color": "#365a94", "parent": "Intelligent Systems", "size": 1.5 }, { "id": "High-Performance Computing (HPC)", "id2": 6, "x": -0.4475, "y": 0.4357, "color": "#800020", "parent": "Compute & Infrastructure", "size": 1.5 }, { "id": "Internet of Things (IoT)", "id2": 12, "x": -1.9357, "y": -1.0323, "color": "#e28f26", "parent": "Connectivity & Networks", "size": 1.5 }, { "id": "Mobile Networks (5G/6G)", "id2": 7, "x": -2.0533, "y": -0.3356, "color": "#e28f26", "parent": "Connectivity & Networks", "size": 1.5 }, { "id": "Quantum Technologies", "id2": 13, "x": 0.2677, "y": 0.5743, "color": "#800020", "parent": "Compute & Infrastructure", "size": 1.5 }, { "id": "Robotics", "id2": 14, "x": 2.4082, "y": -0.4932, "color": "#365a94", "parent": "Intelligent Systems", "size": 1.5 }, { "id": "Satellite Connectivity", "id2": 9, "x": -2.1793, "y": 0.4468, "color": "#e28f26", "parent": "Connectivity & Networks", "size": 1.5 }, { "id": "Semiconductors/Chips", "id2": 10, "x": -0.0092, "y": 1.6825, "color": "#800020", "parent": "Compute & Infrastructure", "size": 1.5 }, { "id": "Software Engineering & System Development", "id2": 11, "x": 0.0072, "y": -1.0322, "color": "#8cab79", "parent": "Digital Foundations & Trust", "size": 1.5 }];

        var links = [{ "source": "Artificial Intelligence", "target": "Computer Vision, Language Processing & Object Recognition", "weight": 41.04 }, { "source": "Artificial Intelligence", "target": "Cybersecurity Technologies", "weight": 14.71 }, { "source": "Blockchain Technologies", "target": "Software Engineering & System Development", "weight": 20.43 }, { "source": "Cloud Computing & Edge Computing", "target": "Cybersecurity Technologies", "weight": 21.76 }, { "source": "Cloud Computing & Edge Computing", "target": "High-Performance Computing (HPC)", "weight": 19.32 }, { "source": "Computer Vision, Language Processing & Object Recognition", "target": "Drones", "weight": 6.9 }, { "source": "Cybersecurity Technologies", "target": "Internet of Things (IoT)", "weight": 17.7 }, { "source": "Cybersecurity Technologies", "target": "Mobile Networks (5G/6G)", "weight": 23.37 }, { "source": "Cybersecurity Technologies", "target": "Software Engineering & System Development", "weight": 19.82 }, { "source": "Drones", "target": "Robotics", "weight": 7.6 }, { "source": "Artificial Intelligence", "target": "Generative AI", "weight": 36.86 }, { "source": "High-Performance Computing (HPC)", "target": "Semiconductors/Chips", "weight": 24.16 }, { "source": "Mobile Networks (5G/6G)", "target": "Satellite Connectivity", "weight": 27.01 }, { "source": "High-Performance Computing (HPC)", "target": "Quantum Technologies", "weight": 16.31 }, { "source": "Computer Vision, Language Processing & Object Recognition", "target": "Artificial Intelligence", "weight": 41.04 }, { "source": "Generative AI", "target": "Artificial Intelligence", "weight": 36.86 }, { "source": "Generative AI", "target": "Computer Vision, Language Processing & Object Recognition", "weight": 36.21 }, { "source": "Computer Vision, Language Processing & Object Recognition", "target": "Generative AI", "weight": 36.21 }, { "source": "Satellite Connectivity", "target": "Mobile Networks (5G/6G)", "weight": 27.01 }, { "source": "Semiconductors/Chips", "target": "High-Performance Computing (HPC)", "weight": 24.16 }, { "source": "Mobile Networks (5G/6G)", "target": "Cybersecurity Technologies", "weight": 23.37 }, { "source": "Cybersecurity Technologies", "target": "Cloud Computing & Edge Computing", "weight": 21.76 }, { "source": "Software Engineering & System Development", "target": "Blockchain Technologies", "weight": 20.43 }, { "source": "Software Engineering & System Development", "target": "Cybersecurity Technologies", "weight": 19.82 }, { "source": "High-Performance Computing (HPC)", "target": "Cloud Computing & Edge Computing", "weight": 19.32 }, { "source": "Internet of Things (IoT)", "target": "Cybersecurity Technologies", "weight": 17.7 }, { "source": "Cybersecurity Technologies", "target": "Blockchain Technologies", "weight": 17.45 }, { "source": "Blockchain Technologies", "target": "Cybersecurity Technologies", "weight": 17.45 }, { "source": "Quantum Technologies", "target": "High-Performance Computing (HPC)", "weight": 16.31 }, { "source": "Cybersecurity Technologies", "target": "Artificial Intelligence", "weight": 14.71 }, { "source": "Cybersecurity Technologies", "target": "Computer Vision, Language Processing & Object Recognition", "weight": 12.75 }, { "source": "Computer Vision, Language Processing & Object Recognition", "target": "Cybersecurity Technologies", "weight": 12.75 }, { "source": "Satellite Connectivity", "target": "Cybersecurity Technologies", "weight": 12.48 }, { "source": "Cybersecurity Technologies", "target": "Satellite Connectivity", "weight": 12.48 }, { "source": "High-Performance Computing (HPC)", "target": "Cybersecurity Technologies", "weight": 12.38 }, { "source": "Cybersecurity Technologies", "target": "High-Performance Computing (HPC)", "weight": 12.38 }, { "source": "Generative AI", "target": "Cybersecurity Technologies", "weight": 12.36 }, { "source": "Cybersecurity Technologies", "target": "Generative AI", "weight": 12.36 }, { "source": "Software Engineering & System Development", "target": "Artificial Intelligence", "weight": 9.56 }, { "source": "Artificial Intelligence", "target": "Software Engineering & System Development", "weight": 9.56 }, { "source": "Mobile Networks (5G/6G)", "target": "Cloud Computing & Edge Computing", "weight": 8.73 }, { "source": "Cloud Computing & Edge Computing", "target": "Mobile Networks (5G/6G)", "weight": 8.73 }, { "source": "Software Engineering & System Development", "target": "Computer Vision, Language Processing & Object Recognition", "weight": 8.06 }, { "source": "Computer Vision, Language Processing & Object Recognition", "target": "Software Engineering & System Development", "weight": 8.06 }, { "source": "Quantum Technologies", "target": "Cybersecurity Technologies", "weight": 7.74 }, { "source": "Cybersecurity Technologies", "target": "Quantum Technologies", "weight": 7.74 }, { "source": "Robotics", "target": "Drones", "weight": 7.6 }, { "source": "Internet of Things (IoT)", "target": "Cloud Computing & Edge Computing", "weight": 7.13 }, { "source": "Cloud Computing & Edge Computing", "target": "Internet of Things (IoT)", "weight": 7.13 }, { "source": "Drones", "target": "Computer Vision, Language Processing & Object Recognition", "weight": 6.9 }, { "source": "Software Engineering & System Development", "target": "Generative AI", "weight": 6.75 }, { "source": "Generative AI", "target": "Software Engineering & System Development", "weight": 6.75 }, { "source": "Semiconductors/Chips", "target": "Quantum Technologies", "weight": 6.48 }, { "source": "Quantum Technologies", "target": "Semiconductors/Chips", "weight": 6.48 }, { "source": "Quantum Technologies", "target": "Generative AI", "weight": 6.34 }, { "source": "Generative AI", "target": "Quantum Technologies", "weight": 6.34 }, { "source": "Mobile Networks (5G/6G)", "target": "Internet of Things (IoT)", "weight": 6.32 }, { "source": "Internet of Things (IoT)", "target": "Mobile Networks (5G/6G)", "weight": 6.32 }, { "source": "Cloud Computing & Edge Computing", "target": "Artificial Intelligence", "weight": 5.81 }, { "source": "Artificial Intelligence", "target": "Cloud Computing & Edge Computing", "weight": 5.81 }, { "source": "Cloud Computing & Edge Computing", "target": "Blockchain Technologies", "weight": 5.58 }, { "source": "Blockchain Technologies", "target": "Cloud Computing & Edge Computing", "weight": 5.58 }, { "source": "Quantum Technologies", "target": "Computer Vision, Language Processing & Object Recognition", "weight": 5.49 }, { "source": "Computer Vision, Language Processing & Object Recognition", "target": "Quantum Technologies", "weight": 5.49 }, { "source": "Blockchain Technologies", "target": "Artificial Intelligence", "weight": 5.45 }, { "source": "Artificial Intelligence", "target": "Blockchain Technologies", "weight": 5.45 }, { "source": "Drones", "target": "Artificial Intelligence", "weight": 5.22 }, { "source": "Artificial Intelligence", "target": "Drones", "weight": 5.22 }, { "source": "Software Engineering & System Development", "target": "Cloud Computing & Edge Computing", "weight": 5.07 }, { "source": "Cloud Computing & Edge Computing", "target": "Software Engineering & System Development", "weight": 5.07 }, { "source": "Quantum Technologies", "target": "Artificial Intelligence", "weight": 4.94 }, { "source": "High-Performance Computing (HPC)", "target": "Blockchain Technologies", "weight": 4.94 }, { "source": "Blockchain Technologies", "target": "High-Performance Computing (HPC)", "weight": 4.94 }, { "source": "Artificial Intelligence", "target": "Quantum Technologies", "weight": 4.94 }, { "source": "High-Performance Computing (HPC)", "target": "Computer Vision, Language Processing & Object Recognition", "weight": 4.82 }, { "source": "Robotics", "target": "Computer Vision, Language Processing & Object Recognition", "weight": 4.22 }, { "source": "Computer Vision, Language Processing & Object Recognition", "target": "Robotics", "weight": 4.22 }];

        var svg = d3.select("svg.network");
        var svgNode = svg.node();
        var width = (svgNode && svgNode.clientWidth) || window.innerWidth;
        var height = (svgNode && svgNode.clientHeight) || Math.round(window.innerHeight * 0.9);
        var nodeRadius = 48;
        var HOR_PADDING = nodeRadius * 2;
        var padding = nodeRadius * 2;

        var extentX = d3.extent(nodes, function (d) { return d.x; });
        var extentY = d3.extent(nodes, function (d) { return d.y; });

        var availableWidth = Math.max(width - padding * 2, padding);
        var availableHeight = Math.max(height - padding * 2, padding);

        var baseLeft = padding;
        var baseRight = padding + availableWidth;

        var minXBound = baseLeft + HOR_PADDING + nodeRadius;
        var maxXBound = baseRight - HOR_PADDING - nodeRadius;

        if (maxXBound <= minXBound) {
            var midpoint = (baseLeft + baseRight) / 2;
            minXBound = midpoint - 1;
            maxXBound = midpoint + 1;
        }

        var horizontalBounds = {
            min: minXBound,
            max: maxXBound
        };

        var scaleX = d3.scaleLinear()
            .domain(extentX)
            .range([horizontalBounds.min, horizontalBounds.max]);

        var scaleY = d3.scaleLinear()
            .domain(extentY)
            .range([padding, padding + availableHeight]);

        function clampX(value) {
            return Math.max(horizontalBounds.min, Math.min(horizontalBounds.max, value));
        }

        nodes.forEach(function (node) {
            var targetX = clampX(scaleX(node.x));
            var targetY = scaleY(node.y);
            node.originalX = targetX;
            node.originalY = targetY;
            node.x = targetX;
            node.y = targetY;
        });

        svg
            .attr("viewBox", [0, 0, width, height])
            .attr("preserveAspectRatio", "xMidYMid meet");

        var container = svg.append("g");

        var zoomBehavior = d3.zoom()
            .scaleExtent([0.6, 3])
            .on("zoom", function (event) {
                container.attr("transform", event.transform);
            });

        svg.call(zoomBehavior);

        var nodeById = new Map(nodes.map(function (node) {
            return [node.id, node];
        }));

        var linkData = links.map(function (link) {
            return {
                source: nodeById.get(link.source),
                target: nodeById.get(link.target),
                weight: link.weight
            };
        }).filter(function (link) {
            return link.source && link.target;
        });

        var linkExtent = linkData.length ? d3.extent(linkData, function (d) { return d.weight || 1; }) : [1, 1];
        if (linkExtent[0] === linkExtent[1]) {
            linkExtent[1] = linkExtent[0] + 1;
        }

        var linkWidth = d3.scaleSqrt()
            .domain(linkExtent)
            .range([0.6, 4]);

        var link = container.append("g")
            .attr("stroke-linecap", "round")
            .selectAll("line")
            .data(linkData)
            .join("line")
            .attr("class", "link")
            .attr("stroke-width", function (d) { return linkWidth(d.weight || 1); });

        var adjacency = new Map();

        linkData.forEach(function (link) {
            var sourceId = link.source.id;
            var targetId = link.target.id;

            if (!adjacency.has(sourceId)) {
                adjacency.set(sourceId, new Set());
            }

            if (!adjacency.has(targetId)) {
                adjacency.set(targetId, new Set());
            }

            adjacency.get(sourceId).add(targetId);
            adjacency.get(targetId).add(sourceId);
        });

        var node = container.append("g")
            .selectAll("g")
            .data(nodes)
            .join("g")
            .attr("class", "node")
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended))
            .on("mouseenter", highlightConnected)
            .on("mouseleave", resetHighlight);

        node.append("circle")
            .attr("r", nodeRadius)
            .attr("fill", function (d) { return d.color; });

        node.append("text")
            .attr("class", "node-label")
            .attr("fill", function (d) {
                return getContrastingTextColor(d.color);
            })
            .style("fill", function (d) {
                return getContrastingTextColor(d.color);
            })
            .call(wrapText, nodeRadius);

        node.append("title")
            .text(function (d) {
                return d.id + (d.parent ? " (" + d.parent + ")" : "");
            });

        renderLegend();

        var simulation = d3.forceSimulation(nodes)
            .alpha(0.9)
            .alphaDecay(0.09)
            .force("collide", d3.forceCollide(nodeRadius + 8).strength(0.95).iterations(4))
            .force("x", d3.forceX(function (d) { return d.originalX; }).strength(1))
            .force("y", d3.forceY(function (d) { return d.originalY; }).strength(1))
            .on("tick", ticked);

        function ticked() {
            nodes.forEach(function (d) {
                d.x = clampX(d.x);
                if (d.fx != null) {
                    d.fx = clampX(d.fx);
                }
            });

            link
                .attr("x1", function (d) { return d.source.x; })
                .attr("y1", function (d) { return d.source.y; })
                .attr("x2", function (d) { return d.target.x; })
                .attr("y2", function (d) { return d.target.y; });

            node.attr("transform", function (d) {
                return "translate(" + d.x + "," + d.y + ")";
            });
        }

        function dragstarted(event, d) {
            if (!event.active) {
                simulation.alphaTarget(0.3).restart();
            }
            d.fx = clampX(d.x);
            d.fy = d.y;
        }

        function dragged(event, d) {
            var clampedX = clampX(event.x);
            d.fx = clampedX;
            d.fy = event.y;
            d.x = clampedX;
            d.y = event.y;
        }

        function dragended(event, d) {
            if (!event.active) {
                simulation.alphaTarget(0);
            }
            d.fx = null;
            d.fy = null;
        }

        function darkenColor(hexColor, factor) {
            factor = factor || 0.5;
            var hex = hexColor.trim().replace("#", "");
            if (hex.length === 3) {
                hex = hex.split("").map(function (ch) { return ch + ch; }).join("");
            }

            var r = parseInt(hex.slice(0, 2), 16);
            var g = parseInt(hex.slice(2, 4), 16);
            var b = parseInt(hex.slice(4, 6), 16);

            r = Math.round(r * factor);
            g = Math.round(g * factor);
            b = Math.round(b * factor);

            return "#" + [r, g, b].map(function (val) {
                var hexVal = val.toString(16);
                return hexVal.length === 1 ? "0" + hexVal : hexVal;
            }).join("");
        }

        function highlightConnected(event, nodeDatum) {
            var neighbors = adjacency.get(nodeDatum.id) || new Set();
            var activeIds = new Set(neighbors);
            activeIds.add(nodeDatum.id);

            node.each(function (d) {
                var isActive = activeIds.has(d.id);
                var nodeElement = d3.select(this);
                nodeElement
                    .classed("highlighted", isActive)
                    .classed("dimmed", !isActive);

                if (isActive) {
                    var darkerColor = darkenColor(d.color, 0.6);
                    nodeElement.select("circle").style("stroke", darkerColor);
                }
            });

            link.each(function (l) {
                var isActive = l.source.id === nodeDatum.id || l.target.id === nodeDatum.id;
                d3.select(this)
                    .classed("highlighted", isActive)
                    .classed("dimmed", !isActive);
            });
        }

        function resetHighlight() {
            node.classed("highlighted", false)
                .classed("dimmed", false)
                .select("circle").style("stroke", null);
            link.classed("highlighted", false)
                .classed("dimmed", false);
        }

        function renderLegend() {
            var legend = d3.select("#legend");
            if (legend.empty()) {
                return;
            }

            legend.attr("role", "list");

            var parentColorMap = new Map();
            nodes.forEach(function (node) {
                var parentName = node.parent || "Other";
                if (!parentColorMap.has(parentName)) {
                    parentColorMap.set(parentName, node.color || "#6c6f7d");
                }
            });

            var legendData = Array.from(parentColorMap, function (entry) {
                return { parent: entry[0], color: entry[1] };
            });

            var legendItems = legend.selectAll(".legend-item")
                .data(legendData, function (d) { return d.parent; });

            legendItems.exit().remove();

            var legendEnter = legendItems.enter()
                .append("div")
                .attr("class", "legend-item")
                .attr("role", "listitem");

            legendEnter.append("span")
                .attr("class", "legend-square");

            legendEnter.append("span")
                .attr("class", "legend-label");

            legendItems = legendEnter.merge(legendItems);

            legendItems.select(".legend-square")
                .style("background-color", function (d) { return d.color; });

            legendItems.select(".legend-label")
                .text(function (d) { return d.parent; });
        }

        function isColorDark(hexColor) {
            if (!hexColor) {
                return false;
            }

            var hex = hexColor.trim().replace("#", "");
            if (hex.length === 3) {
                hex = hex.split("").map(function (ch) { return ch + ch; }).join("");
            }

            if (hex.length !== 6) {
                return false;
            }

            var r = parseInt(hex.slice(0, 2), 16) / 255;
            var g = parseInt(hex.slice(2, 4), 16) / 255;
            var b = parseInt(hex.slice(4, 6), 16) / 255;

            var convert = function (channel) {
                return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);
            };

            var lum = 0.2126 * convert(r) + 0.7152 * convert(g) + 0.0722 * convert(b);
            return lum < 0.55;
        }

        function getContrastingTextColor(hexColor) {
            return isColorDark(hexColor) ? "#ffffff" : "#1b1d21";
        }

        function wrapText(selection, radius) {
            var diameter = radius * 2;
            var maxWidth = diameter * 0.85;
            var maxHeight = diameter * 0.85;
            var lineHeightMultiplier = 1.15;
            var minFontSize = 8;

            selection.each(function (d) {
                var text = d3.select(this);
                var label = (d.id || "").trim();

                text.selectAll("tspan").remove();
                text.text("");

                if (!label) {
                    return;
                }

                var words = label.split(/\s+/).filter(function (word) { return word.length; });
                if (!words.length) {
                    text.append("tspan")
                        .attr("x", 0)
                        .attr("y", 0)
                        .text(label);
                    return;
                }

                var maxFontSize = Math.min(16, radius * 0.45);
                var startingFontSize = Math.max(Math.round(maxFontSize), minFontSize);
                var bestFit = null;

                for (var fontSize = startingFontSize; fontSize >= minFontSize; fontSize -= 1) {
                    var layout = layoutLines(text, words, fontSize, lineHeightMultiplier, maxWidth);
                    bestFit = layout;
                    var totalHeight = layout.lines.length * layout.lineHeight;

                    if (layout.maxLineWidth <= maxWidth && totalHeight <= maxHeight) {
                        break;
                    }
                }

                if (!bestFit) {
                    bestFit = {
                        lines: [label],
                        fontSize: minFontSize,
                        lineHeight: Math.round(minFontSize * lineHeightMultiplier)
                    };
                }

                text.style("font-size", bestFit.fontSize + "px");
                text.selectAll("tspan").remove();

                var offset = (bestFit.lines.length - 1) * bestFit.lineHeight / 2;

                bestFit.lines.forEach(function (line, index) {
                    text.append("tspan")
                        .attr("x", 0)
                        .attr("y", -offset + index * bestFit.lineHeight)
                        .text(line);
                });
            });

            function layoutLines(text, words, fontSize, lineHeightMultiplier, maxWidth) {
                text.style("font-size", fontSize + "px");
                text.selectAll("tspan").remove();

                var lines = [];
                var currentLine = [];
                var maxLineWidth = 0;

                words.forEach(function (word) {
                    currentLine.push(word);
                    var tester = text.append("tspan")
                        .attr("x", 0)
                        .attr("y", 0)
                        .text(currentLine.join(" "));
                    var lineLength = tester.node().getComputedTextLength();
                    tester.remove();

                    if (lineLength > maxWidth && currentLine.length > 1) {
                        currentLine.pop();
                        var finalized = currentLine.join(" ");
                        var measureFinal = text.append("tspan")
                            .attr("x", 0)
                            .attr("y", 0)
                            .text(finalized);
                        var finalLength = measureFinal.node().getComputedTextLength();
                        measureFinal.remove();

                        lines.push(finalized);
                        maxLineWidth = Math.max(maxLineWidth, finalLength);

                        currentLine = [word];
                        var measureWord = text.append("tspan")
                            .attr("x", 0)
                            .attr("y", 0)
                            .text(word);
                        var wordLength = measureWord.node().getComputedTextLength();
                        measureWord.remove();
                        maxLineWidth = Math.max(maxLineWidth, wordLength);
                    } else {
                        maxLineWidth = Math.max(maxLineWidth, lineLength);
                    }
                });

                if (currentLine.length) {
                    var finalLine = currentLine.join(" ");
                    var finalTester = text.append("tspan")
                        .attr("x", 0)
                        .attr("y", 0)
                        .text(finalLine);
                    var finalLineLength = finalTester.node().getComputedTextLength();
                    finalTester.remove();

                    lines.push(finalLine);
                    maxLineWidth = Math.max(maxLineWidth, finalLineLength);
                }

                var lineHeight = Math.max(Math.round(fontSize * lineHeightMultiplier), Math.ceil(fontSize));

                return {
                    lines: lines,
                    fontSize: fontSize,
                    lineHeight: lineHeight,
                    maxLineWidth: maxLineWidth
                };
            }
        }

    </script>

</body>

</html>