<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <script src="https://www.paballand.com/js/d3plus-plot.v0.9.full.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, Helvetica, sans-serif;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #chart {
            flex: 1 1 auto;
        }

        .legend {
            display: flex;
            justify-content: center;
            padding: 12px 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 24px;
            font-size: 14px;
        }

        .box {
            width: 14px;
            height: 14px;
            margin-right: 10px;
            border: none;
        }

        .pos {
            background: #2d7c2d;
        }

        .neg {
            background: #8B1A0F;
        }

        .tooltip-table {
            width: 100%;
        }

        .tooltip-table .data {
            text-align: right;
        }

        .tooltip-footer {
            opacity: .5;
        }

        tspan {
            font-family: "Helvetica", "Arial", sans-serif;
            font-size: 100px;
            font-style: oblique;
        }

        .custom-label {
            font-family: Arial, Helvetica, sans-serif;
            font-size: 13px;
            fill: #000;
            opacity: 1;
            font-weight: normal;
            transition: opacity 0.4s ease, font-size 0.4s ease, font-weight 0.4s ease;
            pointer-events: none;
            transform-origin: center;
        }

        .custom-label.collision {
            opacity: 0.3;
        }

        .custom-label.hover {
            opacity: 1 !important;
            font-size: 16px !important;
            font-weight: bold !important;
        }

        .custom-label,
        text.custom-label {
            font-family: Arial, Helvetica, sans-serif !important;
            font-size: 13px;
            fill: #000 !important;
            stroke: none !important;
            font-weight: normal !important;
        }

        .connector-line {
            stroke: #000;
            stroke-width: 1px;
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="chart"></div>
        <div class="legend">
            <div class="legend-item"><span class="box pos"></span><span>Investment RCA &gt; 1</span></div>
            <div class="legend-item"><span class="box neg"></span><span>Investment RCA &lt; 1</span></div>
        </div>
    </div>
    <script>
        function median(v) {
            if (!v.length) throw new Error("empty");
            v = [...v].sort((a, b) => a - b);
            const h = Math.floor(v.length / 2);
            return v.length % 2 ? v[h] : (v[h - 1] + v[h]) / 2;
        }

        function truncateText(text, maxLength = 35) {
            if (text.length <= maxLength) {
                return text;
            }
            return text.substring(0, maxLength) + "...";
        }

        function rectanglesOverlap(rect1, rect2) {
            return !(rect1.x + rect1.width < rect2.x ||
                rect2.x + rect2.width < rect1.x ||
                rect1.y + rect1.height < rect2.y ||
                rect2.y + rect2.height < rect1.y);
        }

        function getPositionOptions(centerX, centerY, radius, padding = 8) {
            const card = [
                { name: 'right', x: centerX + radius + padding, y: centerY + 5, anchor: 'start' },
                { name: 'left', x: centerX - radius - padding, y: centerY + 5, anchor: 'end' },
                { name: 'below', x: centerX, y: centerY + radius + padding + 10, anchor: 'middle' },
                { name: 'above', x: centerX, y: centerY - radius - padding, anchor: 'middle' }
            ];

            const diagPad = padding;
            const diagOffset = (radius + diagPad) * 0.707;
            const extraX = 4;

            const diag = [
                { name: 'top-right', x: centerX + diagOffset + extraX, y: centerY - diagOffset, anchor: 'start' },
                { name: 'bottom-right', x: centerX + diagOffset + extraX, y: centerY + diagOffset + 5, anchor: 'start' },
                { name: 'bottom-left', x: centerX - diagOffset - extraX, y: centerY + diagOffset + 5, anchor: 'end' },
                { name: 'top-left', x: centerX - diagOffset - extraX, y: centerY - diagOffset, anchor: 'end' }
            ];

            return [...card, ...diag];
        }

        function hasCollision(textElement, obstacles, ignoreCircle) {
            try {
                const rawBBox = textElement.getBBox();
                const pad = 2;
                const textBBox = {
                    x: rawBBox.x + pad,
                    y: rawBBox.y + pad,
                    width: Math.max(0, rawBBox.width - pad * 2),
                    height: Math.max(0, rawBBox.height - pad * 2)
                };

                for (const obs of obstacles) {
                    if (obs.isCircle && obs.ref === ignoreCircle) continue;

                    if (rectanglesOverlap(textBBox, obs)) {
                        return true;
                    }
                }
                return false;
            } catch (e) {
                return false;
            }
        }

        function isOutOfBounds(textElement, bounds) {
            if (!bounds) return false;
            try {
                const bbox = textElement.getBBox();
                const margin = 5;
                if (bbox.x < bounds.x + margin ||
                    bbox.y < bounds.y + margin ||
                    (bbox.x + bbox.width) > (bounds.x + bounds.width - margin) ||
                    (bbox.y + bbox.height) > (bounds.y + bounds.height - margin)) {
                    return true;
                }
                return false;
            } catch (e) {
                return false;
            }
        }

        function findBestPosition(textElement, centerX, centerY, radius, obstacles, fullText, bounds, currentCircle, manualDirection) {
            const positions = getPositionOptions(centerX, centerY, radius);
            const truncatedText = truncateText(fullText, 35);

            if (manualDirection !== undefined && manualDirection !== null) {
                const directionMap = {
                    0: 'right',
                    1: 'bottom-right',
                    2: 'below',
                    3: 'bottom-left',
                    4: 'left',
                    5: 'top-left',
                    6: 'above',
                    7: 'top-right'
                };

                const dir = directionMap[manualDirection];
                const manualPos = positions.find(p => p.name === dir);
                if (manualPos) {
                    textElement.textContent = fullText;
                    textElement.setAttribute('x', manualPos.x);
                    textElement.setAttribute('y', manualPos.y);
                    textElement.setAttribute('text-anchor', manualPos.anchor);

                    const isColliding = hasCollision(textElement, obstacles, currentCircle);
                    return { ...manualPos, text: fullText, hasCollision: isColliding, isManual: true };
                }
            }

            let hasCollisionWithFull = false;

            textElement.textContent = fullText;
            for (const pos of positions) {
                textElement.setAttribute('x', pos.x);
                textElement.setAttribute('y', pos.y);
                textElement.setAttribute('text-anchor', pos.anchor);

                if (!hasCollision(textElement, obstacles, currentCircle) && !isOutOfBounds(textElement, bounds)) {
                    return { ...pos, text: fullText, hasCollision: false };
                }
            }

            hasCollisionWithFull = true;

            hasCollisionWithFull = true;

            textElement.textContent = truncatedText;
            for (const pos of positions) {
                textElement.setAttribute('x', pos.x);
                textElement.setAttribute('y', pos.y);
                textElement.setAttribute('text-anchor', pos.anchor);

                if (!hasCollision(textElement, obstacles, currentCircle) && !isOutOfBounds(textElement, bounds)) {
                    return { ...pos, text: truncatedText, hasCollision: hasCollisionWithFull };
                }
            }

            return { ...positions[0], text: truncatedText, hasCollision: true };
        }

        function getBoundData(element) {
            if (element.__data__) {
                return element.__data__;
            }

            let parent = element.parentElement;
            while (parent) {
                if (parent.__data__) {
                    return parent.__data__;
                }
                parent = parent.parentElement;
            }

            return null;
        }

        function findMatchingDataPoint(circle) {
            const bound = circle.__data__ || d3.select(circle).datum();
            if (bound) return bound;
            console.warn('No data bound to circle:', circle);
            return null;
        }

        var data = [
            {
                "id": "Advanced Manufacturing",
                "x": 31.32,
                "y": 61,
                "rca": 1.83,
                "color": "#679A67",
                "value": 0.5,
                "rca_pub": 1.83
            },
            {
                "id": "Advanced Materials",
                "x": 53.75,
                "y": 61.88,
                "rca": 0.47,
                "color": "#BC9191",
                "value": 0.5,
                "rca_pub": 0.47
            },
            {
                "id": "Advanced Therapy Medicinal Products (ATMP)",
                "x": 91.88,
                "y": 64.79,
                "rca": 2.22,
                "color": "#579257",
                "value": 0.5,
                "rca_pub": 2.22,
                "labelDirection": 5
            },
            {
                "id": "Artificial Intelligence",
                "x": 12.19,
                "y": 76.09,
                "rca": 1.01,
                "color": "#C5CCC5",
                "value": 0.5,
                "rca_pub": 1.01
            },
            {
                "id": "Autonomous Robots",
                "x": 12.85,
                "y": 68.39,
                "rca": 0.43,
                "color": "#BA8A8A",
                "value": 0.5,
                "rca_pub": 0.43
            },
            {
                "id": "Bioinformatics",
                "x": 76.89,
                "y": 71.15,
                "rca": 3.51,
                "color": "#378137",
                "value": 0.5,
                "rca_pub": 3.51
            },
            {
                "id": "Biomanufacturing",
                "x": 88.67,
                "y": 62.49,
                "rca": 1.63,
                "color": "#72A072",
                "value": 0.5,
                "rca_pub": 1.63
            },
            {
                "id": "Biotechnology",
                "x": 84.71,
                "y": 62.73,
                "rca": 1.82,
                "color": "#679A67",
                "value": 0.5,
                "rca_pub": 1.82,
                "labelDirection": 3
            },
            {
                "id": "Carbon Capture & Storage",
                "x": 55.35,
                "y": 52.8,
                "rca": 0,
                "color": "darkred",
                "value": 0.5,
                "rca_pub": 0
            },
            {
                "id": "Cloud and Edge Computing",
                "x": 6,
                "y": 74.04,
                "rca": 0.17,
                "color": "#A95757",
                "value": 0.5,
                "rca_pub": 0.17
            },
            {
                "id": "Cybersecurity",
                "x": 8.81,
                "y": 76.37,
                "rca": 4.03,
                "color": "#2F7D2F",
                "value": 0.5,
                "rca_pub": 4.03
            },
            {
                "id": "Defence Technologies",
                "x": 7.34,
                "y": 40.3,
                "rca": 0.28,
                "color": "#B17070",
                "value": 0.5,
                "rca_pub": 0.28
            },
            {
                "id": "Drones",
                "x": 13.94,
                "y": 65.97,
                "rca": 0.47,
                "color": "#BC9191",
                "value": 0.5,
                "rca_pub": 0.47
            },
            {
                "id": "Food Technology",
                "x": 75.96,
                "y": 54.02,
                "rca": 3.23,
                "color": "#3C843C",
                "value": 0.5,
                "rca_pub": 3.23
            },
            {
                "id": "Generative AI",
                "x": 11.62,
                "y": 73.1,
                "rca": 0.69,
                "color": "#C7AFAF",
                "value": 0.5,
                "rca_pub": 0.69
            },
            {
                "id": "Genomics & Gene Editing",
                "x": 89.68,
                "y": 63.83,
                "rca": 0,
                "color": "darkred",
                "value": 0.5,
                "rca_pub": 0,
                "labelDirection": 4
            },
            {
                "id": "High-Performance Computing (HPC)",
                "x": 19.44,
                "y": 70.93,
                "rca": 0,
                "color": "darkred",
                "value": 0.5,
                "rca_pub": 0,
                "labelDirection": 0
            },
            {
                "id": "Immunotherapy",
                "x": 90.67,
                "y": 62.72,
                "rca": 2.12,
                "color": "#5A945A",
                "value": 0.5,
                "rca_pub": 2.12
            },
            {
                "id": "Internet of Things (IOT)",
                "x": 12.41,
                "y": 76.38,
                "rca": 0.47,
                "color": "#BC9191",
                "value": 0.5,
                "rca_pub": 0.47
            },
            {
                "id": "Medical Devices",
                "x": 33.58,
                "y": 57.68,
                "rca": 0.65,
                "color": "#C5AAAA",
                "value": 0.5,
                "rca_pub": 0.65
            },
            {
                "id": "Microelectronics",
                "x": 29.17,
                "y": 69.9,
                "rca": 0.26,
                "color": "#B06C6C",
                "value": 0.5,
                "rca_pub": 0.26
            },
            {
                "id": "mRNA Technology",
                "x": 95.67,
                "y": 67.09,
                "rca": 1.63,
                "color": "#72A072",
                "value": 0.5,
                "rca_pub": 1.63,
                "labelDirection": 5
            },
            {
                "id": "Nanotechnologies",
                "x": 60.72,
                "y": 60.84,
                "rca": 0.37,
                "color": "#B78080",
                "value": 0.5,
                "rca_pub": 0.37
            },
            {
                "id": "Natural Language Processing",
                "x": 10.72,
                "y": 75.44,
                "rca": 0.84,
                "color": "#CDC1C1",
                "value": 0.5,
                "rca_pub": 0.84
            },
            {
                "id": "Nuclear Energy",
                "x": 40.08,
                "y": 53.83,
                "rca": 0.86,
                "color": "#CEC4C4",
                "value": 0.5,
                "rca_pub": 0.86
            },
            {
                "id": "Pharmaceuticals",
                "x": 74.74,
                "y": 57.98,
                "rca": 1.64,
                "color": "#71A071",
                "value": 0.5,
                "rca_pub": 1.64
            },
            {
                "id": "Photonics",
                "x": 31.61,
                "y": 71.29,
                "rca": 0,
                "color": "darkred",
                "value": 0.5,
                "rca_pub": 0
            },
            {
                "id": "Precision Medicine",
                "x": 73.59,
                "y": 65.67,
                "rca": 0,
                "color": "darkred",
                "value": 0.5,
                "rca_pub": 0,
                "labelDirection": 6
            },
            {
                "id": "Quantum computing",
                "x": 14.36,
                "y": 71.3,
                "rca": 0,
                "color": "darkred",
                "value": 0.5,
                "rca_pub": 0
            },
            {
                "id": "Regenerative Medicine",
                "x": 75.11,
                "y": 58.91,
                "rca": 0,
                "color": "darkred",
                "value": 0.5,
                "rca_pub": 0
            },
            {
                "id": "Robotics",
                "x": 16.46,
                "y": 61.73,
                "rca": 0.81,
                "color": "#CCBEBE",
                "value": 0.5,
                "rca_pub": 0.81
            },
            {
                "id": "Semiconductors",
                "x": 32.81,
                "y": 73.83,
                "rca": 1.43,
                "color": "#80A780",
                "value": 0.5,
                "rca_pub": 1.43
            },
            {
                "id": "Sensor Technologies",
                "x": 23.44,
                "y": 62.66,
                "rca": 0.12,
                "color": "#A44949",
                "value": 0.5,
                "rca_pub": 0.12
            },
            {
                "id": "Smart Grids",
                "x": 8.96,
                "y": 68.91,
                "rca": 1.4,
                "color": "#82A982",
                "value": 0.5,
                "rca_pub": 1.4
            },
            {
                "id": "Smart Materials",
                "x": 43.13,
                "y": 59.57,
                "rca": 0.17,
                "color": "#A95757",
                "value": 0.5,
                "rca_pub": 0.17
            },
            {
                "id": "Space technologies",
                "x": 8.48,
                "y": 72.69,
                "rca": 0.28,
                "color": "#B17070",
                "value": 0.5,
                "rca_pub": 0.28
            },
            {
                "id": "Waste Management",
                "x": 52.47,
                "y": 50.11,
                "rca": 0.4,
                "color": "#B98585",
                "value": 0.5,
                "rca_pub": 0.4
            },
            {
                "id": "Wind Energy",
                "x": 16.81,
                "y": 46.66,
                "rca": 2.59,
                "color": "#4B8C4B",
                "value": 0.5,
                "rca_pub": 2.59
            }
        ];

        const xVals = data.map(d => d.x);
        const yVals = data.map(d => d.y);
        const medianX = median(xVals);
        const medianY = median(yVals);
        const xDomain = [-5, 105];
        const minY = Math.min(...yVals) - 5;
        const maxY = Math.max(...yVals) + 5;

        let customLabels = [];
        let isUpdating = false;
        let hoveringElements = new Set();

        new d3plus.Plot()
            .select("#chart")
            .data(data)
            .annotations([{
                data: [{ id: "Trend", x: medianX, y: minY },
                { id: "Trend", x: medianX, y: maxY },
                { id: "Baseline", x: xDomain[0], y: medianY },
                { id: "Baseline", x: xDomain[1], y: medianY }], shape: "Line", stroke: "#c3c3c3", strokeDasharray: "10", strokeWidth: 2
            }])
            .groupBy(["parent", "id"])
            .tooltipConfig({
                body: d => `<table class='tooltip-table'>
      <tr><td class='title'>Relatedness Density:</td><td class='data'>${d.x}</td></tr>
      <tr><td class='title'>Complexity:</td><td class='data'>${d.y}</td></tr>
      <tr><td class='title'>RCA:</td><td class='data'>${d.rca}</td></tr>
      <tr><td class='title'>ID:</td><td class='data'>${d.id}</td></tr>
    </table>`,
                title: d => d.id
            })
            .size("value")
            .sizeMin(12.75)
            .sizeMax(12.75)
            .color("color")
            .label("")
            .shapeConfig({
                Circle: {
                    labelConfig: { fontSize: 0 }
                }
            })
            .yConfig({
                title: "Technological Complexity",
                titleConfig: { fontSize: () => 16 },
                gridConfig: { stroke: "transparent" },
                shapeConfig: { labelConfig: { fontSize: () => 16 } }
            })
            .yDomain([minY, maxY])
            .xDomain(xDomain)
            .xConfig({
                title: "Technological Relatedness Density",
                titleConfig: { fontSize: () => 16 },
                gridConfig: { stroke: "transparent" },
                shapeConfig: { labelConfig: { fontSize: () => 16 } }
            })
            .legend(false)
            .downloadButton(false)
            .render();

        setTimeout(() => {
            initializeCustomLabels();
            startPositionUpdater();
        }, 500);

        function initializeCustomLabels() {
            const svg = document.querySelector('#chart svg');
            if (!svg) {
                setTimeout(initializeCustomLabels, 100);
                return;
            }

            const circles = svg.querySelectorAll('circle');
            console.log('Found circles:', circles.length);

            circles.forEach((circle, index) => {
                let matchingData = findMatchingDataPoint(circle);

                if (matchingData) {
                    // Refresh data from global source to ensure we have all properties (e.g. labelDirection)
                    const originalData = data.find(d => d.id === matchingData.id);
                    if (originalData) {
                        matchingData = originalData;
                    }

                    console.log('Circle', index, 'matched to data:', matchingData.id, 'Direction:', matchingData.labelDirection);

                    const fullText = matchingData.id;

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('class', 'custom-label');
                    text.setAttribute('data-id', matchingData.id);
                    text.setAttribute('text-anchor', 'start');
                    text.setAttribute('font-family', 'Arial, Helvetica, sans-serif');
                    text.setAttribute('font-size', '13');
                    if (matchingData.labelColor) {
                        text.setAttribute('fill', matchingData.labelColor);
                        text.style.fill = matchingData.labelColor;
                    } else {
                        text.setAttribute('fill', '#000');
                    }
                    text.setAttribute('font-weight', 'normal');
                    text.textContent = fullText;

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('class', 'connector-line');

                    svg.appendChild(line);
                    svg.appendChild(text);

                    customLabels.push({
                        circle: circle,
                        text: text,
                        line: line,
                        data: matchingData,
                        fullText: fullText,
                        defaultText: fullText,
                        savedPosition: null
                    });

                    circle.addEventListener('mouseenter', () => {
                        hoveringElements.add(text);

                        const labelData = customLabels.find(l => l.circle === circle);
                        if (labelData) {
                            labelData.savedPosition = {
                                x: text.getAttribute('x'),
                                y: text.getAttribute('y'),
                                anchor: text.getAttribute('text-anchor'),
                                content: text.textContent
                            };
                        }

                        text.classList.add('hover');
                        text.textContent = fullText;

                        console.log('Hovering over:', matchingData.id);
                    });

                    circle.addEventListener('mouseleave', () => {
                        hoveringElements.delete(text);

                        text.classList.remove('hover');

                        const labelData = customLabels.find(l => l.circle === circle);
                        if (labelData && labelData.savedPosition) {
                            text.setAttribute('x', labelData.savedPosition.x);
                            text.setAttribute('y', labelData.savedPosition.y);
                            text.setAttribute('text-anchor', labelData.savedPosition.anchor);
                            text.textContent = labelData.savedPosition.content;
                        }
                    });
                } else {
                    console.log('Circle', index, 'could not be matched to data');
                }
            });

            updateLabelPositions();
        }

        function updateLabelPositions() {
            if (isUpdating) return;
            isUpdating = true;

            const svg = document.querySelector('#chart svg');
            if (!svg) {
                isUpdating = false;
                return;
            }

            const chartDiv = document.getElementById('chart');
            const width = chartDiv ? chartDiv.clientWidth : window.innerWidth;
            let currentFontSize = 13;
            if (width < 600) currentFontSize = 9;
            else if (width < 900) currentFontSize = 11;

            customLabels.forEach(({ text }) => {
                if (text) {
                    text.setAttribute('font-size', currentFontSize);
                    text.style.fontSize = currentFontSize + 'px';
                }
            });

            const circlePositions = [];

            customLabels.forEach(({ circle, text }) => {
                if (circle && text) {
                    const bbox = circle.getBoundingClientRect();
                    const svgRect = svg.getBoundingClientRect();

                    const svgPoint = svg.createSVGPoint();
                    svgPoint.x = bbox.left + bbox.width / 2 - svgRect.left;
                    svgPoint.y = bbox.top + bbox.height / 2 - svgRect.top;

                    const screenCTM = svg.getScreenCTM();
                    if (screenCTM) {
                        const svgCoords = svgPoint.matrixTransform(screenCTM.inverse());
                        circlePositions.push({
                            circle: circle,
                            coords: svgCoords
                        });
                    }
                }
            });

            const obstacles = circlePositions.map(c => {
                const r = parseFloat(c.circle.getAttribute('r')) || 7.5;
                return {
                    x: c.coords.x - r,
                    y: c.coords.y - r,
                    width: r * 2,
                    height: r * 2,
                    isCircle: true,
                    ref: c.circle
                };
            });

            let bounds = null;
            if (svg) {
                try {
                    const screenCTM = svg.getScreenCTM();
                    if (screenCTM) {
                        const inverseCTM = screenCTM.inverse();
                        const rect = svg.getBoundingClientRect();

                        const p1 = svg.createSVGPoint();
                        p1.x = rect.left;
                        p1.y = rect.top;
                        const min = p1.matrixTransform(inverseCTM);

                        const p2 = svg.createSVGPoint();
                        p2.x = rect.right;
                        p2.y = rect.bottom;
                        const max = p2.matrixTransform(inverseCTM);

                        bounds = {
                            x: min.x,
                            y: min.y,
                            width: max.x - min.x,
                            height: max.y - min.y
                        };
                    }
                } catch (e) {
                    console.log('Error calculating bounds', e);
                }
            }

            customLabels.forEach((labelData) => {
                const { circle, text, line, fullText } = labelData;

                if (hoveringElements.has(text)) {
                    return;
                }

                if (circle && text) {
                    const circleData = circlePositions.find(cp => cp.circle === circle);
                    if (circleData) {
                        const r = parseFloat(circle.getAttribute('r')) || 7.5;
                        const bestPosition = findBestPosition(
                            text,
                            circleData.coords.x,
                            circleData.coords.y,
                            r,
                            obstacles,
                            fullText,
                            bounds,
                            circle,
                            labelData.data ? labelData.data.labelDirection : null
                        );

                        text.setAttribute('x', bestPosition.x);
                        text.setAttribute('y', bestPosition.y);
                        text.setAttribute('text-anchor', bestPosition.anchor);
                        text.textContent = bestPosition.text;
                        labelData.defaultText = bestPosition.text;

                        if (bestPosition.hasCollision && !bestPosition.isManual) {
                            text.classList.add('collision');
                            text.setAttribute('opacity', '0.3');
                        } else {
                            text.classList.remove('collision');
                            text.setAttribute('opacity', '1');
                        }

                        if (line) {
                            line.setAttribute('opacity', (bestPosition.hasCollision && !bestPosition.isManual) ? '0.2' : '0.5');

                            const cx = circleData.coords.x;
                            const cy = circleData.coords.y;
                            let lx1, ly1, lx2, ly2;

                            const name = bestPosition.name;

                            lx1 = cx; ly1 = cy;
                            lx2 = bestPosition.x; ly2 = bestPosition.y;

                            if (name === 'right') {
                                lx1 = cx + r; ly1 = cy;
                                lx2 = bestPosition.x - 2; ly2 = cy;
                            } else if (name === 'left') {
                                lx1 = cx - r; ly1 = cy;
                                lx2 = bestPosition.x + 2; ly2 = cy;
                            } else if (name === 'above') {
                                lx1 = cx; ly1 = cy - r;
                                lx2 = cx; ly2 = bestPosition.y + 2;
                            } else if (name === 'below') {
                                lx1 = cx; ly1 = cy + r;
                                lx2 = cx; ly2 = bestPosition.y - 12;
                            } else if (name === 'top-right') {
                                lx1 = cx + r * 0.7; ly1 = cy - r * 0.7;
                                lx2 = bestPosition.x - 2; ly2 = bestPosition.y - 4;
                            } else if (name === 'bottom-right') {
                                lx1 = cx + r * 0.7; ly1 = cy + r * 0.7;
                                lx2 = bestPosition.x - 2; ly2 = bestPosition.y - 5;
                            } else if (name === 'bottom-left') {
                                lx1 = cx - r * 0.7; ly1 = cy + r * 0.7;
                                lx2 = bestPosition.x + 2; ly2 = bestPosition.y - 5;
                            } else if (name === 'top-left') {
                                lx1 = cx - r * 0.7; ly1 = cy - r * 0.7;
                                lx2 = bestPosition.x + 2; ly2 = bestPosition.y - 4;
                            }

                            line.setAttribute('x1', lx1);
                            line.setAttribute('y1', ly1);
                            line.setAttribute('x2', lx2);
                            line.setAttribute('y2', ly2);
                        }

                        const bbox = text.getBBox();
                        obstacles.push({
                            x: bbox.x,
                            y: bbox.y,
                            width: bbox.width,
                            height: bbox.height,
                            isCircle: false
                        });
                    }
                }
            });

            isUpdating = false;
        }

        function startPositionUpdater() {
            function updateLoop() {
                updateLabelPositions();
                requestAnimationFrame(updateLoop);
            }

            updateLoop();

            const chartElement = document.getElementById('chart');
            if (chartElement) {
                chartElement.addEventListener('wheel', updateLabelPositions, { passive: true });
                chartElement.addEventListener('mousedown', updateLabelPositions);
                chartElement.addEventListener('mousemove', updateLabelPositions);
                chartElement.addEventListener('mouseup', updateLabelPositions);
            }
        }
    </script>
    <div style="position:fixed;right:10px;bottom:10px;font-size:11px;color:#888;z-index:9999;">
    </div>
</body>

</html>